\documentclass{article}
\usepackage{zed-csp}
\begin{document}
\section*{Document Control System}

Here we model a simple document control system in Z.
People who work together need to share their work, but there are many
opportunities for misunderstandings and confusion.  Errors can be
introduced when two people working on the same thing --- a file of
program code, for example --- make changes that conflict with each
other.  We can enlist the computer to help prevent such errors: this
is the purpose of a document control system.  Real examples include
SCCS (source code control system) and RCS (revision control
system).

Here is an excerpt from the informal description:

\begin{quote}
    If a user wants to check out a document in order to change
    the document and the user  has the permission to change it, 
    and nobody else is changing it at the moment, then that user
    may check the document out.

    As soon as a user has checked out a document for editing
    everyone else is disallowed from checking it out (of course people with
    read permission can read it).

    When the user is done editing the document, it should be
    checked in, allowing another user to check it out.
\end{quote}

Here is the Z model.  We begin by introducing two basic sets that
hold everything of interest in this universe, namely people and
documents:

\begin{zed} [PERSON, DOCUMENT] \end{zed}
Some people have permission to change particular documents.  We can model
that as a relation on documents and people:

\begin{axdef}
	permission: DOCUMENT \rel PERSON
\end{axdef}
This relation is just a set of pairs of the form $(document, person)$.
For example, Doug can change the specification, Aki and Doug can
change the design, and Aki and Phil can change the code.

\begin{axdef}
	doug, aki, phil: PERSON \\
	spec, design, code: DOCUMENT
\end{axdef}
\begin{zed}
	permission = \{ (spec, doug), (design, doug), (design, aki), (code, aki), (code, phil) \}
\end{zed}
The state of the system is merely another relation of the same type,
this one saying which documents are actually checked out to whom.   The
central requirement is that a document can only be checked out to
one person at a time, so in this case the relation is a function:
it associates each object in the domain with a single
object in the range.  

\begin{schema}{Documents}
	checked\_out: DOCUMENT \pfun PERSON
\where
	checked\_out \subseteq permission
\end{schema}
Note that $checked\_out$ is a partial function, indicated by the stroke
through the arrow $\pfun$.  This means that some documents might not be
checked out to anybody.  The predicate says that documents can only be
checked out to people who have permission to change them.

A possible state of our system occurs when Doug has checked out the
specification and design, and Phil has checked out the code.

\begin{zed} 
	checked\_out = \{ (design, doug), (spec, doug), (code, phil) \}
\end{zed}

We need two operations that change the state, $CheckOut$ and $CheckIn$.
Here is $CheckOut$.  It has two input parameters, the person $p?$ and the document $d?$.

\begin{schema}{CheckOut}
	\Delta Documents \\
	p?: PERSON \\
	d?: DOCUMENT
\where
	d? \notin \dom checked\_out \\
	(d?, p?) \in permission \\
	checked\_out' = checked\_out \cup \{(d?, p?)\}
\end{schema}
$CheckOut$ has two preconditions.  They are the predicates that contain
no primed ``after'' variables.  First, document $d?$ can't already be checked
out: it can't be in the domain of $checked\_out$.  Moreover, the person
doing the checking out needs permission:  $(d?, p?)$ must belong to
$permission$.  If the preconditions are satisfied we add the pair $(d?,p?)$
to $checked\_out$; this prevents anyone else from checking out $d?$.

We must account for cases where the preconditions are not satisfied.
There are two preconditions, so there must be two such cases.
$CheckedOut$ says that the document is already checked out: $d? \in
\dom checked\_out$.  $Unauthorized$ expresses that the person does not 
have permission: $(d?,p?) \notin permission$.  In both cases nothing
gets checked out and the state of the system does not change:
$\Xi~Documents$.

\begin{zed}
CheckedOut \defs [~ \Xi Documents; d?: DOCUMENT | d? \in \dom checked\_out ~]
\end{zed}

\begin{schema}{Unauthorized}
	\Xi Documents \\
	p?: PERSON \\
 	d?: DOCUMENT
\where
	(d?,p?) \notin permission
\end{schema}
The total operation $T\_CheckOut$ covers all three possibilities.

\begin{zed}
	T\_CheckOut \defs CheckOut \lor CheckedOut \lor Unauthorized
\end{zed}
This concludes our presentation.  This little study illustrates some 
typical features of Z models:

You can ignore details in order to focus on the aspects of the problem
you are interested in.  Here we concentrated on permissions and
keeping track of who has checked out what.  We did not model actually
copying documents back and forth between the central repository and
users' local directories.  We modelled the collections of documents
and users as fixed sets, and the permissions as a constant.  A real
document control system would have to provide some way to enter new
documents into the system and delete old ones, and there would also
have to be a way to assign and change permissions.  If we wished to 
model all that in Z we could represent people, documents, and
permissions as variables in the state schema instead of basic types
and global constants.

Models should be simple.  If you find yourself writing complicated functions
and quantified predicates, it is usually a sign that you are on the wrong
track.  Let the basic properties of sets, relations and functions do the
work for you.  The requirement that only one person at a time can check out
a document can be neatly expressed by a function.

The requirements about permissions can be represented by letting the
$checked\_out$ function be a subset of the $permission$ relation.  In
Z, functions are relations and relations are sets, so operators
defined for sets also apply to relations and functions, and you can
put them all together in the same expressions.  This is an advantage
of Z that you don't find in every formal notation.







% text.tex

\section*{Text Processing}

Here we model a word counting utility, and formatting operations such
as filling paragraphs.

\section{Breaking a text into words}

We begin by defining a set of characters.  A text is just a
sequence of characters.  Certain characters are {\em blanks}.  Spaces, line
breaks, and tabs are certainly blanks, but we might also choose to include
punctuation marks and other special characters.  In fact, we define a 
{\em word} to be a sequence of non-blank characters, 
so a blank is any character
that might separate two words.  A {\em space} is a sequence of blank
characters.  

\begin{zed} [CHAR] \end{zed}
\begin{axdef} blank: \power CHAR \end{axdef}
\begin{zed}
        TEXT == \seq CHAR
\also
	SPACE == \seq_1 blank \\
\also
	WORD == \seq_1 (CHAR \setminus blank)
\end{zed}
$TEXT$ includes the empty sequence, but $SPACE$ and $WORD$ must have
at least one character, so we declare them to be $\seq_1$ (non-empty
sequences).

Our word counting and formatting utilities are based on a function called
$words$.  The $words$ function returns the sequence of all the words in a
text.  For example,

\begin{zed}
words~\langle H,o,w,~,a,r,e,~,y,o,u,? \rangle = \langle \langle H,o,w \rangle , \langle a,r,e \rangle , \langle y,o,u \rangle \rangle
\end{zed}
Clearly $words$ is a total function from a $TEXT$ to a sequence of $WORD$.
To define $words$, we consider all possible patterns of words and spaces, and
write an equation for each. 

\begin{axdef}
        words: TEXT \fun \seq WORD
\where 
        \forall s: SPACE; w: WORD; l,r: TEXT  @ \\
\t1		words~ \langle \rangle = \langle \rangle \land \\
\t1		words~ s = \langle \rangle \land \\
\t1		words~ w = \langle w \rangle \land \\
\t1		words~(s \cat r) = words~r \land \\
\t1		words~(l \cat s) = words~l \land \\
\t1		words~(l \cat s \cat r) = (words~l) \cat (words~r)
\end{axdef}
As you can see, there really aren't so many patterns. When the text is empty,
the result is an empty.  When the text is nothing but space, the
result is empty too.  When the text is a single word, the result is a
sequence that contains just that word.  When the text begins or ends with a
space, you can strip it off; the result is the same.  Wherever
the interior of the text contains a space, you can discard the space and 
break the text in two.   That's it.

This example illustrates several Z techniques that can make definitions
shorter and clearer than code.  The function is applied to {\em patterns}
like $l \cat s \cat r$ that reveal the internal structure of their arguments.
If you think in terms of code that has to work its way through the text from
beginning to end, you can't use patterns in this way.  The definition is
{\em recursive}: the function being defined can appear on both sides of an
equation.  (The definition is not circular: by repeatedly applying the
equations to any text, we will eventually arrive at the simple cases.)
Finally, the last equation is {\em nondeterministic}: it doesn't tell us
where to begin breaking between words; any space is as good as another.  We
don't need to assume that the text will be scanned in order from beginning
to end.

The definition might seem obvious, but it includes cases that are often
forgotten.  Published programs that purport to fill paragraphs break down
when presented with an empty file, or a text that ends with a series of
blank lines.  The errors are not just coding bugs; they reveal a failure to
understand the problem fully.  Writing formal definitions encourages us to 
think carefully about all the cases.  We don't have to complain, as some
programmers do, that there are so many possibilities we can't consider
them all.

\section{A word counting utility}

The number of words in text $t$ is simply $\# (words~t)$.  We can define a
function similar to $words$ that breaks a text into lines.  We consider a 
line break to be a special blank character named $nl$ (for new line).

%%\begin{axdef} nl: blank \end{axdef}
%%\begin{zed} LINE == \seq_1 (CHAR \setminus \{ nl \}) \end{zed}
%%\begin{axdef} lines: TEXT \fun \seq LINE \end{axdef}
%%unchecked
\begin{axdef}
        lines: TEXT \fun \seq LINE
\where 
	\dots \mbox{definition omitted} \dots
\end{axdef} 
Now we have everything we need to write a formal specification for the Unix
word counting utility $wc$.  This popular utility is actually a function
whose argument is a file name, and whose result is a tuple whose components
are the number of lines, words and characters in the file.  A typical
application looks like this:

\[
\mbox{{\tt \% wc structure.tex}}\\
\mbox{{\tt 110 559 4509}}
\]
Here is the definition of $wc$:

\begin{axdef}
	wc: TEXT \fun (\nat \cross \nat \cross \nat)
\where
	\forall file: TEXT @ \\
\t1		wc~file = (\# (lines~file), \# (words~file), \# file)
\end{axdef}
Or, if you like to be more terse

\begin{zed}
   wc == (\lambda file: TEXT @ (\# (lines~file), \# (words~file), \# file))
\end{zed}

\section{Filling paragraphs}

Almost any text editor provides a {\em fill} operation.  The fill operation
transforms raggedy-looking text with lines of different lengths into
nicely formatted text with lines nearly the same length.

For example, you can type in something that looks like this:

\begin{verbatim}
     Almost any text editor provides a fill 
     operation. The fill operation transforms raggedy-looking text 
     with lines of
     different lengths into nicely formatted text with lines
     nearly the same length.
\end{verbatim}

and then you can use the fill operation to turn it into this:

\begin{verbatim}
     Almost any text editor provides a fill operation.  The
     fill operation transforms raggedy-looking text with lines of
     different lengths into nicely formatted text with lines
     nearly the same length.
\end{verbatim}

Let's define the fill operation in Z.  We observe that fill is just one
example of a {\em format} operation that changes the appearance of a text by
breaking lines in different places, and expanding or contracting the spaces
between words, subject to the constraint that no line exceeds the page 
width.  Moreover, a format operation must not change the content of the text:
it preserves the same words in their original order.

\begin{axdef} width: \nat \end{axdef}
\begin{schema}{Format}
	t,t': TEXT
\where
	words~t' = words~t \\
	\forall l: \ran~(lines~t') @ \# l \leq width
\end{schema} 
The fill operation is a format operation that satisfies an additional
constraint: the lines should be filled as much as possible.  There are many
different ways to express this, and each one results in a slightly different
appearance to the text.  Perhaps the simplest rule is to require that the
filled text occupy the fewest possible lines.  

\begin{schema}{Fill}
	Format
\where
	\# (lines~t') = min~ \{ t': TEXT | Format @ \# (lines~t') \}
\end{schema}
This definition says that $Fill$ is essentially a {\em minimization}
operation: it is the specialization of $Format$ that minimizes the
number of lines.  The schema is a little tricky because $Format$ is
used in two different ways and different occurrences of $t'$ represent
different things.  The $t'$ on the left of the equal sign is the final
state of $Fill$.  The $t'$ inside the set comprehension is different:
it is a bound variable that ranges over all final states of $Format$
that can be reached from the initial state of $Fill$.  Inside the set
comprehension, $Format$ is used as a predicate.  The $t$ in this
$Format$ is free: it is the initial state of the enclosing schema
$Fill$.

$Fill$ is nondeterministic.  There are usually many different ways to
place line breaks and spaces that achieve the same minimal number of
lines.  In specifications, nondeterminism is usually a good thing.  We
should only ask for what we really want.  Nondeterministic definitions
are often shorter and clearer because they can omit unimportant
details.  When we come to implementation, they give us the freedom to
make choices that can increase efficiency or convenience.  Moreover,
nondeterministic definitions enable us to build up specifications by a
process of increasing specialization.  Just as $Fill$ is a
specialization of $Format$, we can define specializations of $Fill$ to
achieve different effects such as justified right margins or minimal
spaces between words.  Z was designed to support this style of
definition by specialization.  It makes the formal texts easy to
understand and enables us to reuse general definitions.












\section{Introduction}

This report presents portions of a formal specification for a real
medical device, a radiation therapy machine. This specification,
rather than the informal prose description, serves as the primary
reference source for programming and test plannning.  A
paper~\cite{jacky95b} describes the development of part of the program
based on the contents of this report.

This formal specification is based on a thorough informal (English
prose) specification presented as Chapters 2 and 8 in~\cite{jacky92}.
Here we attempt to formalize the requirements in that
source.  We have included many cross-references.  Decimal numbers and
integers (as in 8.4, 191) refer to chapter, section and page numbers
in~\cite{jacky92}, respectively.

The formal specification is expressed in the Z
notation~\cite{spivey92}.  We have corrected syntax and type errors
detected by a checker~\cite{spivey92a}.

\section{Overview} 

Much of the apparent complexity in the prose requirements arises from
the interaction of several subsystems which, by themselves, are
simpler.  In the formal specification we partition the system
into subsystems and describe simple operations on each.  For each
operation on the system as a whole, we define a separate operation on
each affected subsystem.  The complex behaviors of the whole system
emerge when we compose these simpler operations together.  

Each subsystem is modelled by a Z state schema and a number of operation
schemas on that state. This partition can itself be represented in Z.

%%unchecked  % none of these defined yet
\begin{schema}{TherapyControl}
	Session \\
	Field \\
	Intlk \\
	\dots \\
	Console \\
\end{schema}
$Session$ (section~\ref{sect:session}) models those aspects of the
treatment session that are related to the prescription database
(section~\ref{sect:prescr} models the database itself).  $Field$
(section~\ref{sect:field}) models the many settings that characterize
a single field.  $Intlk$ (section~\ref{sect:intlk}) models software
interlocks and other flags that indicate readiness. $Console$
(section~\ref{sect:ui}) models the user interface.
Section~\ref{sect:compose} combines operations from $Session$, $Field$
and $Console$.

Related operations in different subsystems are distinguished by
suffix: $ExptModeS$, $ExptModeF$, and $ExptModeC$ are operations in
the $Session$, $Field$ and $Console$ subsystems, respectively.  

Each user interface operation in the $Console$ subsystem ensures that
corresponding operations in the $Session$ and $Field$ subsystems are only
invoked when their preconditions are satisfied.  Therefore only the
$Console$ operations need to be total; usually there is no need to
define total operations in the $Session$ and $Field$ subsystems.  For
example the $ExptModeC$ operation in the $Console$ subsystem checks the
precondition that only physicists can invoke this operation; in
$Console$ we define what happens when an operator who is not a
physicist attempts to enter experiment mode.  Therefore $ExptModeS$
and $ExptModeF$ can assume that this precondition has been satisfied
and need not cover the other cases.

\section{System configuration} \label{sect:config}

Fixed aspects of the system configuration are represented by Z global
constants: sets, functions and relations.  This section introduces
some of these constants.  It should be possible to accommodate some
configuration changes simply by changing their values.

\subsection{Settings and registers} \label{sect:settings}

The state of the therapy machine is largely determined by the values
of named $items$.  At this writing the list of items is

\begin{zed} 
ITEM ::= nfrac | dose\_tot | dose | wedge | w\_rot | filter | leaf0 | leaf39 | \\
\t3	gantry | collim | turnt | lat | longit | height | doseB | top | \\
\t3	pt\_mode | pt\_factor | press | temp | d\_rate | t\_fac | \\
\t3	calvolt1 | calvolt2 | p\_dose | p\_time | e\_time
\end{zed}
For brevity we omit formal declarations of the other collimator $leaves$,
$leaf1 \upto leaf38$.

There are many items but we can identify different subsets, where all
of the members of each subset are treated the same way for some
particular purpose.
  
$Settings$ are items which are included in field prescriptions.  Other
items are kept in $registers$.  In particular $dose\_reg$ items
include calibration factors and other items concerned with the
dosimetry system\footnote{In the C implementation $setting$ and
$dose\_reg$ are two different enumerations, separated so we can
efficiently store and index zero-based C arrays.  We may add other
register enumerations in the future, for example for the LCC
calibration factors.}.

\begin{axdef}
	setting, dose\_reg: \power ITEM \\
\end{axdef}
At this writing

\begin{zed}
	\langle setting, dose\_reg \rangle \partition ITEM
\also
	dose\_reg = \{ pt\_mode, pt\_factor, press, temp, d\_rate, t\_fac, \\
\t3		calvolt1, calvolt2, p\_dose, p\_time, e\_time \}
\end{zed}
{\em Scales} are items that are continously variable over some range;
examples are gantry angle and every collimator leaf position.  
{\em Selections} can only take on certain discrete values; examples are
wedge and flattening filter selection.  {\em Counters} accumulate
during treatment runs; examples are dose and the number of fractions.

\begin{axdef}
	scale, selection, counter: \power ITEM
\end{axdef}
At this writing

\begin{zed}
	\langle selection, scale, counter \rangle \partition ITEM
\also
	counter = \{ nfrac, dose\_tot, dose \} \\
	selection = \{ wedge, w\_rot, filter, pt\_mode \} \\
\end{zed}
A field is prescribed by determining the values of certain of its
settings.  Therapy fields are defined by the values of particular
settings called {\em prescriptions}.  Experiment fields are defined by
the values of settings called {\em presets} (8.2, 171 third bullet;
Table 8.2, 173).  Readiness is determined by checking all the $preset$
settings in experiment mode, and all the $prescr$ settings ($prescrip$
except the linear table motions) in therapy mode (8.9.8, 194).
Most settings are machine $motions$, and the actual values of most
settings are measured by $sensors$.  The {\em calibration constants}
are registers that are initially loaded with constants stored in the
calibration database.  At this writing



\begin{zed}
	leaves == \{ leaf0, leaf39 \}
\also
	preset == leaves \cup \{wedge, w\_rot, filter \}
\also
	motion == preset \cup \{ gantry, collim, turnt, lat, longit, height \}
\also
	prescrip == motion \cup counter 
\also
	prescr == prescrip \setminus \{ lat, longit, height \}
\also
	sensor == setting \setminus \{ nfrac, dose\_tot \}
\also
	cal\_const == \{ d\_rate, t\_fac, calvolt1, calvolt2 \}
\end{zed}

\subsection{Values} \label{sect:values}

The value of every item can be represented by a number.

\begin{zed}
	VALUE == \num
\end{zed}
Each item will be implemented by an appropriate
(possibly floating point) numeric type.  In this report it is
sufficient to say they are all numbers, to indicate that we can
do arithmetic with them.

Each item can assume a particular range of $valid$ (physically
achievable) values.  For example, the gantry angle can vary from 0 to
359\footnote{In the implementation gantry angle varies from 0.0 to
359.9. Decimal fractions are not built into Z.}; the available wedge
selections are $no\_wedge$, 30, 45 and 60.  We use $valid$ to do range
checking on numbers that the operator types in, and also on
sensor readings, to check for faults\footnote{The
C implementation includes one $valid$ array indexed by $setting$ and
another (with a different name) indexed by $dose\_reg$.}.  Every
setting~$s$ has some valid values, and there is always a minimum and a
maximum valid value. We define
an uninitialized or $blank$ value which is not valid for any setting.
For each $scale$ item, there is a {\em tolerance} within which
variations in value are acceptable.

\begin{axdef}
	blank: VALUE \\
        tol: scale \fun VALUE \\
	valid: ITEM \fun \finset_1 VALUE
\where
	\forall s: ITEM @ blank \notin valid~s \\
\end{axdef}

\section{Prescription database} \label{sect:prescr}

The prescription database stores patients and fields.  We define a
basic type for the names that identify them.

\begin{zed}
	[NAME]
\also
	PATIENT == NAME; FIELD == NAME
\end{zed}
An item's name usually corresponds to the text string that identifies
it in screen displays and log files\footnote{We define one type for
both kinds of names so the same specifications (and code) can be used
to handle lists of patients and fields.  In the implementation,
elements of $NAME$ are integer indices into arrays, usually of C
structures that include the name string as one member.}.

We distinguish a special value to indicate that no name has been
selected.

\begin{axdef}
	no\_name: NAME \\
\end{axdef}
\begin{zed} no\_patient == no\_name; no\_field == no\_name \end{zed}
In experiment mode, we store fields under {\em studies} which are
analogous to patients.  In our model they have the same type.

\begin{axdef}
	studies,patients: \power PATIENT
\where
	no\_patient \notin studies \land no\_patient \notin patients
\end{axdef}
For each patient or study, several prescribed fields are
stored\footnote{This differs from~\cite{jacky90d}, which describes a
single collection of experiment fields.  Moreoever, for each
experiment field we now store the same $prescrip$ settings as for
therapy fields, although we only check the $preset$ settings for
agreement with the stored prescription}.  We must check against
delivering too many fractions or monitor units from the same field
(8.9.4, 187 -- 188), so the accumulated values of the counters are
also stored (for patient fields only).

\begin{zed}
	ACCUMULATION == counter \fun VALUE
\also
 	PRESCRIPTION == prescrip \fun VALUE
\end{zed}

\begin{axdef}	
	Preset: studies \fun (FIELD \pfun PRESCRIPTION) \\
	Prescribed: patients \fun (FIELD \pfun PRESCRIPTION) \\
	Accumulated: patients \fun (FIELD \pfun ACCUMULATION) \\
\where
	\forall s: studies @ no\_field \notin \dom (Preset~s) \\
	\forall p: patients @ no\_field \notin \dom (Prescribed~p)
			\land \dom~(Prescribed~p) = \dom~(Accumulated~p) 
\end{axdef}

The $exceeded$ predicate tests whether the prescribed fractional dose,
total dose or number of fractions have already been delivered.

%%prerel exceeded

\begin{axdef}
	exceeded \_ : ACCUMULATION \rel PRESCRIPTION
\where
	\forall counters: ACCUMULATION; fields: PRESCRIPTION @ \\
	\t1 exceeded(counters,fields) \iff (\exists c: counter @ counters~c \geq fields~c)
\end{axdef}
In the following discussion consider field $f$ of patient $p$; let
$prescribed = Prescribed~p~f$ and $accumulated = Accumulated~p~f$.
The prescription includes the number of fractions $prescribed~n$ and
the total dose $prescribed~dose\_tot$.  We also keep track of the
number of fractions accumulated to date $accumulated~n$, the number of
monitor units delivered since the beginning of the day
$accumulated~dose$ and the total number of monitor units accumulated
to date $accumulated~dose\_tot$ (8.9.4, Fig. 83, 186).

% check syntax of higher order function appl.
%% \begin{zed} pf == \{ p: PATIENT; f: FIELD @ Prescribed~p~f \} \end{zed}

\subsection{Operators} \label{sect:opers}

Our $OPERATOR$ type includes the operator's username and password.  A
special value indicates no operator has logged in.  Physicists are
operators who are authorized to use the equipment in its experiment
mode (8.2, 170).

\begin{zed} [OPERATOR] \end{zed}

\begin{axdef}
	no\_operator: OPERATOR \\
	operators, physicists: \power OPERATOR
\where
	physicists \subseteq operators
\end{axdef}

\section{Session} \label{sect:session}

In this section we model those aspects of the treatment session that
are related to the prescription database.  In
section~\ref{sect:compose}, we will combine the operations defined
here with user interface operations described in
section~\ref{sect:ui}.

\subsection{Session state}

The $Session$ state is determined by the treatment $mode$, the
$operator$ on duty, the currently selected $patient$ and $field$, the
accessible $names$ (patients or studies), and the accessible
prescribed $fields$ and their $counters$.  We first define
$SessionVars$ which declares all the state variables and provides
predicates to ensure that the operator is authorized for the mode, and
the names are consistent with the mode.

\begin{zed}
	MODE ::= therapy | experiment
\end{zed}

\begin{schema}{SessionVars}
	mode: MODE \\
	operator: OPERATOR \\
	patient: PATIENT \\
	field: FIELD \\
	names: \power PATIENT \\
	fields: FIELD \pfun PRESCRIPTION \\
	counters: FIELD \pfun ACCUMULATION \\
\where
	operator = no\_operator \lor operator \in operators \\
	mode = experiment \implies operator \in physicists \\
	names = \IF mode = therapy \THEN patients \ELSE studies
\end{schema}
Next, we define two cases.  When no patient is selected, no
prescribed fields are accessible; no field can be selected.

\begin{schema}{NoPatient}
	SessionVars
\where
	patient = no\_patient \\
	field = no\_field \\
	fields = \emptyset \\
	counters = \emptyset \\
\end{schema}
When a patient is selected, that patient's fields are accessible.
If a field is selected, it must be one of these.

\begin{schema}{PrescribedPatient}
	SessionVars
\where
	patient \neq no\_patient \\
	patient \in names \\
	field = no\_field \lor field \in \dom fields \\
	fields = \IF mode = therapy \THEN Prescribed~patient \ELSE Preset~patient \\
	mode = therapy \implies counters = Accumulated~patient \\
\end{schema}
Together these define the $Session$ state.

\begin{zed} Session \defs PrescribedPatient \lor NoPatient \end{zed}
The $Session$ subsystem starts up in therapy mode with no operator and
no patient.

\begin{schema}{InitSession}
	NoPatient
\where
	mode = therapy \\
	operator = no\_operator \\
\end{schema}
None of the $Session$ state variables are sensor inputs; all are under
program control.

\subsection{Operations on Session}

In the following subsections we model the operations on $Session$.  We
will put together the operations defined in different states in
section~\ref{sect:compose}, below.

\subsubsection{Experiment mode} \label{sect:expt-mode-s}

Physicists can toggle the session from therapy mode to experiment mode
and back\footnote{This is a change from the original requirements
in~\cite{jacky90d}, where {\bf Experiment Mode} switches to experiment
mode but {\bf Select Patient} switches back to therapy mode.}. The
user interface ensures that only physicists can invoke this operation,
so there is no need here to define a total operation that describes
what happens when an operator who is not a physicist attempts this
operation.  After switching modes, no patient (study) and no field are
selected (8.9.6, 190 -- 191).

\begin{schema}{ExptModeS}
	\Delta Session \\
\where
	operator \in physicists \\
	NoPatient' \\
	(mode',names') = \IF mode = therapy \THEN (experiment,studies) \\
\t9						\ELSE (therapy,patients) \\
	operator' = operator
\end{schema}

\subsubsection{Store Field}

{\bf Store Field} (8.9.5, 189 -- 188) accepts a new field name, which
becomes the selected field and is also added to the list of
fields\footnote{The prose~\cite{jacky92} also requires that the new
field be added to the prescription database for the current patient.
We do not model this formally (in fact we model the prescription
database as a constant).  The precondition $patient \neq no\_patient$
is not explicit in the prose.}.

\begin{schema}{StoreFieldS}
	\Delta Session \\
	field?: FIELD \\
	prescribed': PRESCRIPTION \\
	accumulated': ACCUMULATION \\
\where
	patient \neq no\_patient \\
	field' = field? \\
	fields' = fields \cup \{ field' \mapsto prescribed' \} \\
	mode = therapy \implies counters' = counters \cup \{ field' \mapsto accumulated' \} \\
\also
	mode' = mode \\
	operator' = operator \\
	patient' = patient \\
	names' = names \\
\end{schema}
Here $prescribed'$ and $accumulated'$ are just place holders; their
values are defined in the corresponding $Field$ operation
$StoreFieldF$.

\subsubsection{Login} \label{sect:login-session}

{\bf Login} (2.5.2, 17 -- 20; 8.9.1, 183) accepts a new $operator?$.
The user interface ensures that the new operator is authorized.

\begin{schema}{NewOperator}
	\Delta Session \\
	operator?: OPERATOR
\where
	operator' = operator? \\
	operator' \in operators
\end{schema}
There are two variations.  Usually the new operator is sufficiently
privileged to keep the same mode.  Otherwise the session reverts to
therapy mode with no patient and no field (8.9.6, 190).

\begin{schema}{Privileged}
	NewOperator
\where
	mode = therapy \lor operator' \in physicists \\
\also
	mode' = mode \\
	patient' = patient \\
	names' = names \\
	field' = field \\
	fields' = fields \\
	counters' = counters 
\end{schema}

\begin{schema}{Unprivileged}
	NewOperator
\where
        mode = experiment \\
        operator \notin physicists \\
	mode' = therapy \\
	NoPatient'
\end{schema}

\begin{zed}
LoginS \defs Privileged \lor Unprivileged
\end{zed}

\subsubsection{Select Patient}

In {\bf Select Patient} (8.9.3, 184 -- 185) the patient's
prescribed fields are loaded, but no field is selected
\footnote{The prose~\cite{jacky90d} says that if the patient list is
selected in experiment mode, the session reverts to therapy mode
(8.9.3, 184 last paragraph).  We have dropped this requirement.}.  The
user interface ensures that the new patient is in the prescription
database.

\begin{schema}{SelectPatientS}
	\Delta Session \\
	patient?: PATIENT
\where
	patient? \in names \\
	patient' = patient? \\
	field' = no\_field \\
	fields' = \IF mode = therapy \THEN Prescribed~patient' \ELSE Preset~patient' \\
	mode = therapy \implies counters' = Accumulated~patient' \\
\also
	mode' = mode  \\
	operator' = operator \\
	names' = names
\end{schema}

\subsubsection{Select Field}

{\bf Select Field} (8.9.4, 186 -- 189) changes the current field.
The user interface ensures this operation cannot occur if there is no
patient, and ensures that the new field is prescribed.

\begin{schema}{SelectFieldS}
	\Delta Session \\
	field?: FIELD
\where
	patient \neq no\_patient \\
	field? \in \dom fields \\
	field' = field? \\
\also
	operator' = operator \\
	mode' = mode \\
	patient' = patient \\
	fields' = fields \\
	counters' = counters
\end{schema}

\section{Field} \label{sect:field}

In this section, we look inside the machine state and deal
with particular machine settings.  We model operations that involve
the many settings that characterize a single field.

\subsection{Field state}

The $Field$ schema includes the state variables that represent
settings for the currently selected $field$ and $mode$.  $Sensors$
report $measured$ setting values.  $Prescribed$ setting values are
read from the prescription database.

$Computed$ and $calibrated$ item values are entered by the operator or
calculated from prescribed settings and calibration constants; these
are stored in $registers$.  Certain {\em calibration constants} are
stored in files (8.9.13, 213 first full paragraph; 215 last
paragraph).  $Counters$ hold setting values that are $accumulated$
over successive runs.  For example, the $dose$ prescribed for a single
fraction may be have to be delivered in two or more treatment runs.

Some settings that do not match their prescribed values can be
$overridden$ by the operator (8.4, 175 second paragraph; 8.8.1, 181).
It is necessary to store the value of each setting when it is
overridden (see the requirement in the last paragraph under
``override'' on p.  181).  Only settings that are prescribed can be
overridden.

\begin{axdef}
	cal\_factor: cal\_const \fun VALUE
\end{axdef}

\begin{schema}{Field}
	prescribed: PRESCRIPTION \\
	accumulated: ACCUMULATION \\
	measured: sensor \fun VALUE \\
	overridden: prescr \pfun VALUE \\
	computed, calibrated: dose\_reg \fun VALUE \\
\end{schema}
The $measured$ settings are read from sensors so here we cannot write any
predicates that constrain them.

\subsection{Relation to Session state}

A few operations on $Field$ read the $mode$ and $field$ state variables
declared in $Session$.  In therapy mode, the $prescribed$ settings in
the $Field$ state are those from the prescription database entry for
the currently selected $mode$ and $field$ in the $Session$ state. (In
experiment mode the prescribed settings are also loaded from the
prescription database but may be changed subsequently.  In therapy
mode the counters are loaded from the prescription database when the
field is selected but may be changed subsequently.  See
section~\ref{sect:sel-field-f}).

\begin{schema}{PrescribedField}
	Field \\
	Session
\where
	field \neq no\_field \\
	mode = therapy \implies prescribed = fields~field \\
\end{schema}
When no field has been selected, prescribed settings and counters have
no values and the computed settings dose and time indicate no dose.
(8.9.7, 192, second paragraph after the bullets).  No settings are
overridden (8.9.8, 194; 8.9.9, 196; 8.9.10, 198).

\begin{zed}
	no\_prescrip == (\lambda p: prescrip @ blank)
\also
	no\_counter == (\lambda c: counter @ blank)
\also
	no\_dose\_reg == (\lambda d: dose\_reg @ blank)
\also
	no\_dose == \{ p\_dose \mapsto blank, p\_time \mapsto blank \} 
\end{zed}

\begin{schema}{NoFieldF}
	Field \\
\where
	prescribed = no\_prescrip \\
	accumulated = no\_counter \\
	no\_dose \subseteq computed \\
	overridden = \emptyset \\
\end{schema}

\begin{zed}
	NoFieldS \defs [ Session | field = no\_field ]
\also
	NoField \defs NoFieldF \land NoFieldS
\end{zed}
$FieldSession$ expresses the combined invariant:

\begin{zed}
FieldSession \defs PrescribedField \lor NoField
\end{zed}

\subsection{Initialization}

$Field$ begins with no field.  The calibration factors
are initialized with the constants on file (8.9.13, 213, second
paragraph after bullets) and the other registers hold no values.

\begin{schema}{InitField}
	NoFieldF
\where
	computed = calibrated = no\_dose\_reg \oplus cal\_factor
\end{schema}

\subsection{Operations on Field}

In the following subsections we model the operations on $Field$.  We
will put together the operations defined in different states in
section~\ref{sect:compose}, below.

\subsubsection{Select Patient}

{\bf SelectPatient} also affects $Field$: when a patient is first selected,
there is no field.


\begin{schema}{SelectPatientF}
	\Delta Field
\where
	NoFieldF' \\
	computed' = computed \oplus no\_dose \\
\also
	calibrated' = calibrated \\
\end{schema}

\subsubsection{Select Field} \label{sect:sel-field-f}

When a new field is selected, its prescribed settings are loaded and
no settings are overridden.  This operation requires read-only access
to the $fields$ state variable in the $Session$ schema.

\begin{schema}{NewFieldF}
	\Delta FieldSession \\
\where
	prescribed' = fields~field' \\
	overridden' = \emptyset \\
\end{schema}
There are two variants of $SelectField$. Experiment mode is much
simpler because there is no prescribed dose.  The prescribed settings
are loaded.  The dose and time do not change (8.9.11, 202, second
paragraph from bottom).

\begin{schema}{SelectExptFieldF}
	NewFieldF \\
\where	
	mode = experiment \\
	computed' = computed \\
	calibrated' = calibrated \\
\end{schema}
Selecting rectangular fields in experimental mode (8.9.4, 188 -- 189)
is not modelled formally.

In therapy mode, the dose for the treatment run and the treatment
backup time are calculated.  Treatment backup time is calculated from
the dose and two calibration factors, the machine's nominal dose rate
$computed~d\_rate$ and the treatment time factor $computed~t\_fac$
(8.9.11, 200, last paragraph; 202, second paragraph; 8.9.13, 213,
first two paragraphs after bullets)\footnote{The backup time is given
by $t\_backup = factor * dose / rate$. For example with prescribed
dose 100.0 MU, dose rate 50.0 MU/min and factor 1.50 the backup time
is 3.00 minutes.  We do not attempt to model this floating-point
calculation in Z.}.

\begin{zed}
	DOSE == VALUE; RATE == VALUE; FACTOR == VALUE; TIME == VALUE
\end{zed}

\begin{axdef}
	t\_backup: (DOSE \cross RATE \cross FACTOR) \pfun TIME
\where
	\forall d: valid~dose; r: valid~d\_rate; f: valid~t\_fac @ \\
\t1	 (d,r,f) \in \dom t\_backup \land t\_backup(d,r,f) \in valid~p\_time
\end{axdef}
We keep track of the number of monitor units delivered since the
beginning of the day $accumulated~dose$.  When the prescribed field
settings are loaded, the computed dose is adjusted to deliver the
remaining daily dose.  This makes it easy to set up another treatment
run for the same field if the earlier attempts had to be interrupted for
any reason, or were used to make a port film.  The treatment backup time is
calculated from this adjusted dose, not the prescribed dose.

The adjusted dose and corresponding backup time are stored in
$computed~p\_dose$ and $calibrated~p\_time$ ($computed~p\_dose$ may
differ from $prescribed~dose$).  There is also a register
$computed~p\_time$ where the user may optionally enter a backup time
different than $calibrated~p\_time$ (section~\ref{sect:editf}, below)
(8.9.11, Fig. 8.8, 199; Fig. 8.9, 203; Fig 8.10, 207; Fig. 8.11, 208).

\begin{schema}{DoseTime}
	\Delta Field
\where
(\LET t == t\_backup(computed'~p\_dose,computed'~d\_rate,computed'~t\_fac) @ \\
\t1	calibrated' = calibrated \oplus \{ ~p\_time \mapsto t \}) \\
	computed'~p\_time = calibrated'~p\_time \\
	\{ p\_dose, p\_time \} \ndres computed' = \{ p\_dose, p\_time \} \ndres computed
\end{schema}
	
\begin{schema}{NewTherapyField}
	NewFieldF \\
	DoseTime \\
\where
	mode = therapy \\
	accumulated' = counters~field' \\ 
\end{schema}
There are two cases.  The normal case occurs when the user interface
confirms that the prescribed fractional
dose, total dose and number of fractions are not yet $exceeded$. The
dose is read from the prescription, and no
settings are overridden (8.9.4, 187).

\begin{schema}{SelectTherapyFieldF}
	NewTherapyField \\
\where
	computed'~p\_dose = prescribed~dose - accumulated~dose \\
	overridden' = \emptyset
\end{schema}
Together these make the simple case

\begin{zed}
	SelectSimpleFieldF \defs SelectExptFieldF \lor SelectTherapyFieldF
\end{zed}
The other case occurs when the user interface acquires the preset dose
from the operator (often when one or more of the counter settings is
$exceeded$.  If this differs from the prescribed dose then dose is
overridden, and any exceeded settings are also overridden (8.9.4,
188).

\begin{schema}{SelectComplexFieldF}
	NewTherapyField \\
	dose?: VALUE
\where
computed'~p\_dose = dose? \\
(\LET ovr == 
 (\lambda c: counter | accumulated'~c \geq prescribed'~c @ accumulated~c) @ \\
\t1  overridden' = \IF dose? = prescribed'~dose \\
\t5			\THEN ovr \ELSE ovr \cup \{ dose \mapsto dose? \})
\end{schema}
Here we have made a few small changes from the prose requirements.
According to the prose (8.9.4, 187 -- 188), the {\bf Select Field}
operation includes a dialog with the operator to enter a new dose or
treatment time in some cases.  In our formal specification it is
necessary for the operator to explicitly select the {\bf Edit}
operation after {\bf Select Field} in order to enter a new dose or
treatment time.  These minor adjustments achieve the intent of the
prose and simplify the program.  As required by the prose, our
$SelectComplexFieldF$ overrides exceeded settings (after operator
confirmation, enforced by the user interface)\footnote{We also
considered the slightly simpler alternative of omitting the operator
confirmation and leaving $overridden = \emptyset$ in the $exceeded$
case.  In that alternative, the $Intlk$ subsystem
(section~\ref{sect:intlk}) would make the offending settings
$not\_ready$ to prevent the field being delivered unless the operator
explicitly edits or overrides those settings.}.

\subsubsection{Edit setting}  \label{sect:editf}

The edit operation updates a $prescribed$ or $computed$ item value.

\begin{schema}{EditF}
	\Delta Field \\
	item?: ITEM \\
	value?: VALUE 
\where
	accumulated' = accumulated \\
	calibrated' = calibrated
\end{schema}
The prose actually describes four {\bf Edit} operations.  Some
features are common to all.  The first variation is for preset
settings; the user interface ensures this can be invoked in experiment
mode only (8.8.1, 180).  The prescribed value is changed, and that
setting is no longer overridden.

\begin{schema}{EditPresetF}
	EditF
\where
	item? \in preset \\
	prescribed' = prescribed \oplus \{ item? \mapsto value? \} \\
	overridden' = \{ item? \} \ndres overridden \\
\also
	computed' = computed \\
\end{schema}
The second variation is for calibration factors; again, the user
interface only provides this in experiment mode
(8.9.3, 215).  Calibration factors that users can edit are
modelled as $computed$ settings in $registers$.  Calibration factors
are never considered overridden.

\begin{schema}{EditCalF}
	EditF
\where
	item? \in dose\_reg \setminus \{ p\_dose, p\_time \} \\
	computed' = computed \oplus \{ item? \mapsto value? \} \\
\also
	prescribed' = prescribed \\
	overridden' = overridden
\end{schema}
The third variation is for dose (8.9.11, 201--202). The computed (not
prescribed) value is changed, and the dose is considered overridden
(8.9.4, 188; 8.9.11, 202).  The treatment times are recalculated.

\begin{schema}{EditDoseF}
	EditF \\
	DoseTime \\
\where
	item? = p\_dose \\
	computed'~p\_dose = value? \\
	overridden' = overridden \oplus \{ dose \mapsto value? \} \\
\also
	prescribed' = prescribed \\
\end{schema}
The fourth and last variation is treatment backup time, which can be
edited in both modes (8.9.11, 202). Here again the computed value is
changed; time is not a prescribed setting, so it cannot be
overridden.

\begin{schema}{EditTimeF}
	EditF
\where
	item? = p\_time \\
	computed' = computed \oplus \{ p\_time \mapsto value? \} \\
\also
	prescribed' = prescribed \\
	overridden' = overridden \\
\end{schema}
Here is the combined operation:

\begin{zed}
EditSettingF \defs 
 EditCalF \lor EditPresetF \lor EditDoseF \lor EditTimeF
\end{zed}
$EditSettingF$ is not a total operation (it does not handle all
possible values of $ITEM$) but the user interface ensures that
its preconditions are always satisfied.

We now provide the $EditDoseF$ and $EditTimeF$ operations instead of
the dialog after {\bf Select Field} proposed in~\cite{jacky92}
(8.9.4, 187 -- 188).

\subsubsection{Override}

Certain items can be overridden.

\begin{schema}{OverF}
	\Delta Field \\
	item?: ITEM 
\where
	prescribed' = prescribed \\
	accumulated' = accumulated \\
	computed' = computed \\
	calibrated' = calibrated
\end{schema}
We add a newly overridden setting and its currently measured value
to the $overridden$ function (8.4, 175 second paragraph; 8.8.1, 181).
If the setting is already overridden, the override is cancelled.

\begin{schema}{OverrideSetting}
	OverF
\where
	item? \in prescr \\
overridden' = \\
\t1 \IF item? \notin \dom overridden \\
\t2	\THEN overridden \oplus \{ item? \mapsto measured~item? \} \\
\t2	\ELSE \{ item? \} \ndres overridden
\end{schema}
Dose and time are special cases; overriding either makes dose
overridden with its accumulated (not measured) value as
the overridden value.  The counters 
total dose $dose\_tot$ and number of fractions
$nfrac$ can only be overridden (after operator confirmation) as part
of the $SelectFieldF$ operation.

\begin{schema}{OverrideDose}
	OverF
\where
	item? \in \{ p\_dose, p\_time \} \\
overridden' = \\
\t1 \IF dose \notin \dom overridden \\
\t2	\THEN overridden \oplus \{ dose \mapsto accumulated~dose \} \\
\t2	\ELSE \{ dose \} \ndres overridden
\end{schema}

\begin{zed} OverrideF \defs OverrideSetting \lor OverrideDose \end{zed}

\subsubsection{Store Field}

This operation (8.9.5, 189 -- 190) makes the prescribed settings equal
to the actual machine settings, except there is no prescribed dose and
the number of fractions is set to one.  The accumulators are reset to
zero.

\begin{zed}
	zero\_counter == (\lambda c: counter @ 0)
\end{zed}

\begin{schema}{StoreFieldF}
	\Delta FieldSession \\
\where
	computed' = computed \oplus no\_dose \\
	prescribed' = prescribed \oplus  (prescrip \dres measured) 
			\oplus no\_counter \oplus \{ nfrac \mapsto 1 \} \\
	accumulated' = zero\_counter \\
	overridden' = \emptyset
\also
	calibrated' = calibrated \\
\end{schema}

% The domain of ``measured'' includes elements not in the domain of ``prescribed''

\subsubsection{Experiment Mode}

This operation toggles modes with no field.  There are
no dose and time (8.9.11, 202, second paragraph from bottom).

\begin{schema}{ExptModeF}
	\Delta Field
\where
	NoFieldF' \\
	computed' = computed \oplus no\_dose
\also
	calibrated' = calibrated
\end{schema}

\subsection{Calibration factors}

\subsubsection{Dosimetry calibration}

Dosimetry calibration factors, including the dose rate and treatment
time factor used to calculate the backup time, appear on the 
{\bf Dosimetry Calibration} display (8.9.13, 213 -- 214)\footnote{Called
{\bf Cal Factors} in~\cite{jacky92}, since renamed to distinguish it
from the forthcoming {\bf LCC Calibration} etc.}.
The $calibrated$ values in the left column are read from
files or measured by sensors, while the $computed$ values in the right
column are computed by the control program or entered by the operator
using the $EditCalF$ operation.

The pressure-temperature correction factors are used to adjust the
standard calibration voltages for the dosimetry system (8.9.13, 213 --
215).  The $calibrated~calvolt1$ and $calibrated~calvolt2$ represent
the standard calibration voltages on file (8.9.13, 213, second
paragraph from bottom), while $computed~calvolt1$ (etc.) represent the
calibration voltages actually in effect, which are obtained by
adusting the standard calibration voltage by a barometric
pressure/temperature correction factor (8.9.13, 213 bottom paragraph,
214 top paragraph)\footnote{The pressure-temperature factor is given
by $pt\_factor = (press/1013) \times (295/(temp+273))$, where $press$
and $temp$ are in mbar and deg. C, respectively. We do not attempt to
model this floating-point calculation in Z.}.

\begin{zed} PRESSURE == VALUE; TEMPERATURE == VALUE \end{zed}

\begin{axdef}
	pt\_formula: (PRESSURE \cross TEMPERATURE) \pfun FACTOR
\where
	\forall p: valid~press; t: valid~temp @ \\
\t1	 (p,t) \in \dom pt\_formula \land pt\_formula(p,t) \in valid~pt\_factor
\end{axdef}
The $computed~press$ and $computed~temp$ are the pressure and
temperature entered by the operator, and while $calibrated~temp$ and
$calibrated~press$ are measured continously by sensors. The
$computed~pt\_factor$ stores the 
{\em barometric pressure/temperature correction factor of the day} 
calculated from the readings entered by
the operator (8.9.13, 214, third paragraph), while
$calibrated~pt\_factor$ stores the 
{\em automatic pressure/temperature correction factor} 
calculated from sensor readings (8.9.13, 214,
fourth paragraph).  The {\em pressure-temperature} interlock
(section~\ref{sect:intlk}) accounts for the possibility that the
pressure or temperature values might be invalid or expired.

The operator sets $computed~pt\_mode = automatic$ to use the 
{\em automatic pressure/temperature correction factor}, 
and $computed~pt\_mode = manual$ to
use the correction factor that is based on the manually entered values (8.9.13,
214, fifth paragraph).

\begin{axdef}
	automatic, manual: VALUE 
\end{axdef}
The $ScanPT$ operation computes the correction factors and updates
the registers with the new values.

\begin{schema}{ScanPT}
	\Delta Field
\where
	calibrated'~pt\_factor = pt\_formula(calibrated~press,calibrated~temp)\\
	computed'~pt\_factor = pt\_formula(computed~press,computed~temp) \\
\also
	(\LET pt\_corr == \IF computed~pt\_mode = automatic \\  
\t5		\THEN calibrated'~pt\_factor \ELSE computed'~pt\_factor @ \\
\t1		computed'~calvolt1 = pt\_corr * calibrated~calvolt1 \land \\
\t1		computed'~calvolt2 = pt\_corr * calibrated~calvolt2) \\
\also
	\{ pt\_factor \} \ndres calibrated' = \{ pt\_factor \} \ndres calibrated \\
	\{ pt\_factor, calvolt1, calvolt2 \} \ndres computed' = \{ pt\_factor, calvolt1, calvolt2 \} \ndres computed \\
\also
	prescribed' = prescribed \\
	accumulated' = accumulated \\
	overridden' = overridden
\end{schema}
$ScanPT$ is scheduled by the control program itself; it is not invoked
by the user.

\section{Software interlocks and status flags} \label{sect:intlk}

(To come)

\newpage

\section{User interface} \label{sect:ui}

The user may provide input at the workstation at any time (by typing,
pressing function keys or cursor arrow keys --- in our implementation
we do not use the mouse).  We model each keystroke and the actions
it invokes as an $Event$ that accepts an $input?$ that may change the
$Console$ state.

%%unchecked
\begin{schema}{Event}
	\Delta Console \\
	input?: INPUT
\end{schema}
We do not attempt to formalize any ``look and feel'' aspects of the
user interface, such as the appearance of the display.  They are
already described in sufficient detail in~\cite{jacky92}, chapters 2
and 8.

$INPUT$ is the set of inputs (keypresses) the user can
provide\footnote{In the implementation, inputs are X window system
events and the values of $INPUT$ correspond to X
keysyms~\cite{nye88}.}.  Here is the list of inputs at this writing.

\begin{zed} 
INPUT ::= filter\_wedge | leaf\_collim | dose\_intlk | gantry\_psa | dose\_cal | \\
\t3	startup | help | messages | select\_patient | select\_field | field\_summary | \\
\t3	login | edit\_setting | edit\_dose\_reg | log\_message | store\_field | override\_cmd | \\
\t3	cancel\_run | password |auto\_setup | expt\_mode | cancel | refresh | shutdown | \\
\t3	 select | ret | character | backspace | delete\_key | \\ 
\t3	left\_arrow | right\_arrow | up\_arrow | down\_arrow | ignored
\end{zed}
Many operations are invoked by pressing keys, so it is often
convenient to identify operations with the corresponding input.
Therefore we assign them to the same type.   Here is the list of 
operations at this writing.

\begin{axdef}
	OP: \power INPUT
\where
OP = \{ filter\_wedge, leaf\_collim, dose\_intlk, gantry\_psa, dose\_cal, \\
\t2 startup, help, messages, select\_patient, select\_field, field\_summary, \\
\t2 login, edit\_setting, edit\_dose\_reg, log\_message, store\_field, override\_cmd, \\
\t2 cancel\_run, password,auto\_setup, expt\_mode, cancel, refresh, shutdown, select \}
\end{axdef}
The user interface shows many displays, for example the login display
(Fig 8.1, 178), the patient list display (Fig. 8.2, 185), the leaf
collimator display (Fig. 8.7, 197) etc.  The operator can choose any
display by pressing a key, so we can identify displays with these
operations.

\begin{axdef}
	DISPLAY: \power OP
\where
DISPLAY = \{ filter\_wedge, leaf\_collim, dose\_intlk, gantry\_psa, dose\_cal, \\
\t3	startup, help, messages, select\_patient, select\_field, \\
\t3	field\_summary, login \}
\end{axdef}

\subsection{Console state}

This section describes the variables in the $Console$ state.  

The first variable indicates the mode of $interaction$.  If no
interaction is in progress the console is $available$, or there
may be a $dialog$ in progress where the user is typing text into a
dialog box, or there may be a $menu$ displayed, or the user may be
asked to $confirm$ some operation by providing a yes/no answer (this
mode can also be used to present informational messages).

\begin{zed}
	INTERACTION ::= available | dialog | menu | confirm
\end{zed}
The $op$ variable keeps track of which top-level operation
(described in~\cite{jacky92}) is underway.

The $display$ variable indicates which of the screen designs pictured
in the informal specification is currently visible on the display.
The $display$ variable determines which items appear and helps
determine which operations are available.  

The $item$ state variable holds the item which the operator has
selected from a tabular display, for example the setting which
the operator is editing.

The $nlist$ state variable holds the list of names (of patients or
fields) that appear on a list display, and $list\_item$ indicates 
the currently selected name.

The $menu\_item$ state variable holds the index of the current menu
selection (a small integer).

\begin{axdef}
	nmax: \nat
\end{axdef}
\begin{zed} SELECTION == \{ i: \nat | i \leq nmax \} \end{zed}
The $buffer$ state variable models the (possibly incomplete) string
that the user edits in dialog mode.

\begin{zed}
	[STRING]
\end{zed}

\begin{axdef}
	empty: STRING
\end{axdef}
The $keyswitch$ must be unlocked to allow the console to be used (8.7, 179).

\begin{zed}
	KEYSWITCH ::= locked | unlocked
\end{zed}
Some operations are available only when a treatment is being set up,
and are locked out while a treatment $run$ is in progress (8.8.2, 183).

\begin{zed}
	RUN ::= setup | running
\end{zed}
The $keyswitch$ and $run$ variables depend on sensor inputs; they are not
constrained here.

Together, these variables describe the state of the user interaction.

\begin{schema}{Console}
	keyswitch: KEYSWITCH \\
	run: RUN \\
	display: DISPLAY \\
	op: OP \\
	interaction: INTERACTION \\
	item: ITEM \\
	nlist: \power NAME \\
	list\_item: NAME \\
	menu\_item: SELECTION \\
	buffer: STRING
\end{schema}
When the control program starts up, the login process begins
(section~\ref{sect:login-console})\footnote{When the implementation
starts up, the $startup$ screen appears first.  The login process does
not begin until the various $Init\dots$ conditions are established.
We do not model this formally.}.

\begin{schema}{InitConsole}
	Console
\where
	op = login \\
	display = login \\
	interaction = dialog \\
	buffer = empty
\end{schema}

\subsection{Elements of user interaction} \label{sect:gui-elts}

All user interactions are built up from a few elements. In this
section we define the constants, states and operations that serve as
building blocks.

The {\em caption} type models messages or other output to the operator
that appear temporarily at the console (in dialog boxes or perhaps
even from the speaker, see 2.2.3, 9).  Captions are distinguished from
{\em log messages} which appear in a different location on the console
and are also stored in log files along with timestamps other
information (2.2.4, 9).

\begin{zed}[CAPTION, MESSAGE]\end{zed}
$Ignore$ is the default do-nothing operation that is
invoked when a key is pressed but the preconditions for the associated
operation are not satisfied.  $Ignore$ does not change the state, but
issues an alert (such as sounding the workstation bell) to notify the
user that the input was received but the operation is not enabled.  

\begin{axdef} alert: CAPTION \end{axdef}

%% \begin{zed} Event \defs [~ \Delta Console; input?: INPUT ~] \end{zed}
\begin{schema}{Ignore}
	Event \\
	\Xi Console \\
	caption!: CAPTION
\where
	caption! = alert
\end{schema}
The keyswitch must be unlocked for any operation to occur.  When the keyswitch is
locked, input is ignored:

\begin{zed}	
	Unlocked \defs [~ Console | keyswitch = unlocked ~]
\also
	EventUnlocked \defs Event \land Unlocked
\end{zed}
Many operations are invoked by pressing the $select$ key.

\begin{zed} 
	Select \defs [~ EventUnlocked | input? = select ~]
\end{zed}
It is convenient to describe the operations that can occur in each of
the interaction modes.  Each mode is described in a following
subsection.

\subsubsection{Available}

Most of the top-level operations described in~\cite{jacky92}
can only be selected when the console is available.

\begin{zed} Available \defs [~ Console | interaction = available ~] \end{zed}

\begin{schema}{Op}
	EventUnlocked
\where
	Available \\
	input? \in OP \\
\end{schema}
Certain operations have stronger preconditions: they cannot occur when
a run is in progress (8.8.2, 183).  A few operations occur only when a
run is in progress (8.9.11, 209-210). 

\begin{zed}
	Setup \defs [~ Available | run = setup ~]
\also
	Running \defs [~ Available | run = running ~]
\end{zed}
When the console is available, the user may select a new $display$.
The console remains available.

\begin{schema}{SelectDisplay}
	Op \\
\where
	input? \in DISPLAY \\
	display' = input?  \\
	op' = display' \\
	Available' \\
\end{schema}
$SelectDisplay$ operations may change $item$ and $list\_item$ (see
below) but do not change other state variables (for brevity we omit
the $x' = x$ ``nothing changes'' predicates).

When an interaction is in progress, the console is $Engaged$.
The $Done$ operation schema describes what happens when an interaction
completes: the console returns to the $Available$ state, and $op$
returns to its value when the display was selected.

\begin{zed} Engaged \defs [ Console | interaction \neq available ] \end{zed}

\begin{schema}{Done}
	EventUnlocked \\
\where
	Engaged \\
	op' = display \\
	display' = display \\
	Available'
\end{schema}

The $Cancel$ operation is used to end an interaction without making
permanent changes to the underlying machine state.

\begin{zed} Cancel \defs [ Done | input? = cancel ] \end{zed}

\subsubsection{Lists}

Certain displays show a list of names (patients or fields).  When a
list display is selected, $nlist$ is loaded, and the default $list\_item$
is assigned. If the list is not empty, the $List$ state results (the
patient list might be empty if there are no patients on file; the
field list is always empty when there is no patient, and may be empty
if there are no fields on file for the selected patient).

\begin{axdef}
	list: \power DISPLAY \\
	default\_name: \power_1 NAME \fun NAME 
\where 
	\forall list: \power_1 NAME @ default\_name~list \in list
\end{axdef}


\begin{zed} 
List \defs [~ Available | display \in list \land nlist \neq \emptyset \land list\_item \in nlist ~]
\end{zed}

\begin{schema}{SelectList}
	SelectDisplay
\where
	input? \in list \\
	((nlist = \emptyset \land list\_item' = no\_name) \\
	\lor (List' \land list\_item' = default\_name~nlist'))
\end{schema}
Here $display \in list \land nlist \neq \emptyset$ distinguishes the
$List$ state, and this test occurs explicitly in the implementation.
In contrast, $list\_item \in nlist$ is an invariant.  It need not be
coded as an explicit test but it must be maintained or else the
implementation might abort (because $list\_item$ is used as an index
into $nlist$).

The console indicates $list\_item$ (for example by placing a highlight
or cursor over that name in the list).  Subsequently the user can
choose a new name from the list by using the up and down-arrow keys.
The function $aname$ calculates the new name by ``dead
reckoning'' from the old name, the list, and the arrow key (it is
not necessary for the program to poll the console for the cursor
position).  The list remains visible.

\begin{zed} v\_arrow == \{ up\_arrow, down\_arrow \} \end{zed}

\begin{axdef}
	aname: (v\_arrow \cross NAME \cross \power_1 NAME) \fun NAME 
\where
	\forall a: v\_arrow; n: NAME; list: \power_1 NAME @ aname(a,n,list) \in list
\end{axdef}

\begin{zed}
Continue \defs [~ \Delta Console | interaction' = interaction \land op' = op \land display' = display ~]
\end{zed}
\begin{schema}{GetListArrow}
	EventUnlocked \\
	\Delta List
\where
	input? \in v\_arrow \\
	list\_item' = aname(input?,list\_item,nlist) \\
	Continue \\
\end{schema}
This is a $Continue$ operation that does not change $interaction$,
$op$, or $display$.  Here $list\_item$ is the only state variable that
changes.  We do not completely specify $default\_name$ and $aname$; we
leave that to the implementation.  Here we merely provide the
predicates needed to ensure that the implementation does not abort.

The user presses the $select$ key to choose the current $list\_item$
for some purpose.  The selection is logged; $nmessage$ converts the
name to a log message.

\begin{axdef}
	selected\_msg: NAME \fun MESSAGE
\end{axdef}

\begin{schema}{SelectName}
	Select \\
	name!: NAME \\
	message!: MESSAGE \\
\where
	List \\
	name! = list\_item \\
	message! = selected\_msg~name!
\end{schema}
$GetListArrow$ and $SelectName$ are not total operations; they do not
handle the case where $nlist = \emptyset$.  The latter case is handled
by a default do-nothing operation, $IgnoreOthers$, which includes
$Ignore$.  We do not define the precondition of this operation
explicitly; we code the implementation so control reaches
$IgnoreOthers$ when no other operations are enabled.


\subsubsection{Tables}

Certain displays show a table of items (settings for one subsystem,
calibration factors etc.).  The constant $table\_items$ tells which
items on each table can be selected for editing or overriding
(additional items may be displayed as well).  When a tabular display
is selected, the default $item$ is assigned, and the $Table$ state
results.

\begin{axdef}
	table: \power DISPLAY
\end{axdef}

\begin{axdef}
	default\_item: table \fun ITEM \\
	table\_items: table \fun \power_1 ITEM \\
\where 
	\forall d: table @ default\_item~d \in table\_items~d
\end{axdef}


\begin{zed}
Table \defs [~ Available | 
		display \in table \land 
		item \in table\_items~display ~]
\end{zed}

\begin{schema}{SelectTable}
	SelectDisplay
\where
	input? \in table \\
	item' = default\_item~display' \\
	Table'
\end{schema}
Subsequently the user can indicate a new item on the table by using
all four arrow keys.

\begin{zed} arrow == \{ right\_arrow, left\_arrow \} \cup v\_arrow \end{zed}

\begin{axdef}
	asetting: (arrow \cross ITEM \cross table) \fun ITEM
\where
	\forall a: arrow; s: ITEM; d: table @ asetting(a,s,d) \in table\_items~d
\end{axdef}

\begin{schema}{GetSettingArrow}
	EventUnlocked \\
	\Delta Table
\where
	input? \in arrow \\
	item' = asetting(input?,item,display) \\
	Continue
\end{schema}
Here $item$ is the only state variable that changes.

Items can be selected from tabular displays for editing or overriding.
Editing or overriding is only enabled in the $Setup$ state (when a
treatment run is not in progress, see 8.8.2, 183).  Pressing the
$select$ key when certain tabular displays are present invokes an
editing operation: $edit\_setting$ if the selected item is a $setting$
and $edit\_dose\_reg$ if it is a $dose\_reg$ (notice that here $op'$ is
{\em not} the same as $input?$).  Therefore it is necessary to
separate $setting$ and $dose\_reg$ items on different
tables\footnote{Because the implementation cannot distinguish
$setting$ from $dose\_reg$ based on $item$ alone; $item$ values are
just C {\tt enum} values (integers).}.

\begin{axdef}
	setting\_table, dose\_reg\_table: \power table
\where
	\forall d: setting\_table @ table\_items~d \subseteq setting \\
	\forall d: dose\_reg\_table @ table\_items~d \subseteq dose\_reg \\
\end{axdef}

\begin{schema}{SelectItem}
	Select
\where
	Setup \\
	Table \\
	item' = item \\
	(op' = edit\_dose\_reg \land display \in dose\_reg\_table \lor \\
	op' = edit\_setting \land display \in setting\_table)
\end{schema}
The postcondition here implies $Editing$, the invariant of the editing
state\footnote{The implementation uses $op$ to determine whether
$item$ is an index into $setting$ or $dose\_reg$.}.

\begin{schema}{Editing}
	Console
\where
	interaction \in \{ dialog, menu \} \\
	(op = edit\_dose\_reg \land item \in dose\_reg \lor \\
	op = edit\_setting \land item \in setting)
\end{schema}
The $Setup$ precondition of $SelectItem$ prevents the console entering
the $Editing$ state when a run is in progress.  Other mechanisms
prevent the machine from beginning a run while in the $Editing$ state.

\subsubsection{Confirm}

$Confirm$ interactions present a query (``Are you sure \dots ?'')  and
wait for the user to provide a yes/no answer, indicated by the
$select$ or $cancel$ keys (for example see 8.9.11, 210).  Each
$Confirm$ operation presents a confirmation box (a sort of dialog box)
with a $caption$ that identifies the operation, and the $query$.  The
display under the confirmation box does not change.
	
\begin{zed}
	Confirm \defs [~ Console | interaction = confirm ~]
\end{zed}

\begin{axdef} 
	ocaption: OP \fun CAPTION \\
\end{axdef}

\begin{schema}{ConfirmOp}
	Op \\
	caption!, query!: CAPTION
\where	
	caption! = ocaption~op' \\
	display' = display \\
	Confirm' \\
\end{schema}
	
\begin{zed}
	AcceptConfirm \defs Confirm \land Select \land Done
\end{zed}

\subsubsection{Menu}

When the console is $Available$ the user can invoke a menu, then make
a selection from the menu.  Each menu includes a caption and a list of
menu entries. The display does not change.

\begin{axdef}
	default\_selection: SELECTION
\end{axdef}

\begin{zed}Menu \defs [~ Editing | interaction = menu ~] \end{zed}

\begin{schema}{MenuOp}
	Op \\
	caption!: CAPTION \\
	menu!: \iseq CAPTION
\where
	menu\_item' = default\_selection \\
	display' = display \\
	Menu'
\end{schema}
Here $op$ also changes; the other state variables retain the same
values.  

Menus are used to choose new values for $selection$ items; valid
$selection$ values are small integers.  Combining $MenuOp$ with
$SelectItem$ yields the $MenuEdit$ operation. The menu shows the item
name and a sequence of descriptive strings indexed by the
corresponding item values. Here again, the $Editing$ postcondition of
$SelectItem$ guarantees that $op$ can be used to help look up
$selection\_values~item$.

\begin{axdef}
	setting\_info\_name: ITEM \fun CAPTION \\
	setting\_value: selection \fun \iseq CAPTION \\
\where
	\forall s: selection @ \dom~(setting\_value~s) = valid~s
\end{axdef}

\begin{schema}{MenuEdit}
	MenuOp \\
	SelectItem \\
\where
	item \in selection \\
	caption! = setting\_info\_name~item;
	menu! = setting\_value~item
\end{schema}
There are functions to return the default menu selection and the new
selection after each up or down-arrow keypress.

\begin{axdef}
	amenu: (v\_arrow \cross SELECTION \cross selection) \fun SELECTION
\where
\forall s: selection @ (\LET n == \# (valid~s) @ \\
\t1	\forall a: v\_arrow; i: SELECTION @ default\_selection \leq n \land amenu(a,i,s) \leq n)
\end{axdef}

\begin{schema}{GetMenuArrow}
	EventUnlocked \\
	\Delta Menu
\where
	input? \in v\_arrow \\
	menu\_item' = amenu(input?,menu\_item,item) \\
	Continue 
\end{schema}
Here $item$ is the only variable that changes.

The user presses $select$ to accept the current menu item and the
console becomes available again.

\begin{zed} AcceptMenu \defs Menu \land Select \land Done \end{zed}

\begin{schema}{MenuSettingC}
	AcceptMenu \\
	item!: ITEM \\
	value!: VALUE
\where
	Editing \\
	item! = item \\
	value! = menu\_item
\end{schema}

\subsubsection{Dialog}

When the console is $Available$ the user can begin a dialog, then type
and edit text in a dialog box.  The dialog box contains a $caption$
and a $prompt$ that may include the values of other state variables.
The display under the dialog box does not change.

\begin{zed} Dialog \defs [~ Console | interaction = dialog ~] \end{zed}

\begin{schema}{DialogOp}
	Op \\
	caption!, prompt!: CAPTION \\
\where
	caption! = ocaption~op' \\
	display' = display \\
	Dialog'
\end{schema}
Here only $interaction$, $buffer$, and $op$ change.  The $buffer$ may
be emptied, or may be filled with a convenient default value.  We'll describe
changes to $op$ later, with each dialog operation.

The console remains in $Dialog$ while the user types and edits.
The $GetChar$ operation gets a single character and
updates the buffer as described by the $modify$ function (append
printing characters to the end of $buffer$, and do the appropriate
things with editing characters).

\begin{axdef}
	CHAR: \power INPUT
\end{axdef}
\begin{axdef}
	modify: (STRING \cross CHAR) \fun STRING
\end{axdef}

\begin{schema}{GetChar}
	EventUnlocked \\
	\Delta Dialog
\where
	input? \in CHAR \\
	buffer' = modify(buffer,input?) \\
	Continue 
\end{schema}
Here $buffer$ is the only variable that changes.

When a dialog is done, the dialog box disappears and the console
becomes available again. At any time the user can $cancel$ the dialog
and discard the input.  To submit the input, the user presses a
$terminator$ key; the program can $Accept$ the input or $Reprompt$
(the user may also $Cancel$ the dialog).

\begin{axdef}
	terminator: \power INPUT
\end{axdef}

\begin{schema}{Accept}
	Done
\where
	Dialog \\
	input? \in terminator
\end{schema}

\begin{schema}{Reprompt}
	EventUnlocked \\
	\Delta Dialog
\where
	input? \in terminator \\
	buffer' = empty \\
	Continue
\end{schema}
Here again, $buffer$ is the only variable that changes.

Dialogs are frequently used to edit item values. Combining $DialogOp$
with $SelectItem$ yields the $DialogEdit$ operation.  Dialog box
editing begins if the selected item is not a $selection$ (does not
have just a few discrete values).  The program captions the dialog box
with the item name and the minimum and maximum valid item
values\footnote{The dialog box caption also includes the units, but we
do not model this formally.}.
	
\begin{zed} MIN == VALUE; MAX == VALUE \end{zed}

\begin{axdef}
	setting\_info: ITEM \cross MIN \cross MAX \fun CAPTION
\end{axdef}

\begin{schema}{DialogEdit}
	DialogOp \\
	SelectItem \\
\where
	item \notin selection \\
	prompt! = (\LET v == valid~item @ setting\_info(item, min~v, max~v))
\end{schema}
The implementation uses the value of $op$ guaranteed by the $Editing$
postcondition of $SelectItem$ to look up $valid~item$; there are
separate $valid$ arrays for $dose\_reg$ and $setting$.

When the user presses a terminator key, the program attempts to
convert the buffer contents to a (numeric) value (non-numeric strings
are always converted to an out-of-range value).  If the conversion
succeeds and the value is valid for the item, the dialog ends and the
item and its value are reported; otherwise, the program reprompts.

\begin{axdef}
	sval: STRING \fun VALUE
\end{axdef}

\begin{schema}{EditSettingC}
	Accept \\
	item!: ITEM \\
	value!: VALUE
\where
	Editing \\
	item! = item \\
	(\LET v == sval~buffer @ v \in valid~item \land value! = v)
\end{schema}

\begin{zed}
InvalidSetting \defs [~ Reprompt | Editing \land sval~buffer \notin valid~item ~]
\end{zed}
In the implementation it is convenient to combine these two
operations\footnote{In $EditOrInvalidSetting$, the two outputs $item!$
and $value!$ are not used in the $Invalid$ case.}.

\begin{zed}
	EditOrInvalidSetting \defs EditSettingC \lor InvalidSetting
\end{zed}

\subsection{Therapy console operations} \label{sect:therapy-ops}

In this subsection we present the operations described
in~\cite{jacky92}.  Several building block operations require no
further elaboration: $SelectDisplay$, $SelectTable$, $GetListArrow$,
$GetSettingArrow$, $Cancel$, $GetMenuArrow$, $MenuSettingC$,
$GetChar$, and $EditOrInvalidSetting$ and are already complete.
Others require further specialization in the following subsections.

\subsubsection{Relation to Session state}

A few $Console$ operations read (but do not change) variables from the
$Session$ state (section~\ref{sect:session}).  When the $Console$
shows the patient or field list, its $nlist$ state variable holds the
patients or fields from the $Session$ state.  This is expressed by the
$ConsoleSession$ invariant:

\begin{schema}{ConsoleSession}
	Console \\
	Session
\where
	display = select\_patient \implies nlist = names \\
	display = select\_field \implies nlist = \dom fields
\end{schema}

\subsubsection{Op operations}

Several operations are based only on $Op$.  They are $Continue$
operations because they do not involve any ongoing interaction, just a
single keypress.

\begin{zed} SimpleOp \defs Op \land Continue \end{zed}

{\bf Experiment Mode} (8.9.6, 190):

\begin{schema}{ExptModeC}
	SimpleOp \\
	\Xi Session \\
	\Delta ConsoleSession \\
\where
	Setup \\
	input? = expt\_mode \\
	operator \in physicists \\
\end{schema}
{\bf Auto Setup} (8.8.1, 181):

\begin{zed}
auto\_setup\_display == \{ field\_summary, filter\_wedge, leaf\_collim, dose\_intlk \}
\end{zed}
\begin{schema}{AutoSetupC}
	SimpleOp \\
	\Xi ConsoleSession \\
	subsystem!: auto\_setup\_display \\
\where
	Setup \\
	field \neq no\_field \\
	display \in auto\_setup\_display \\
	input? = auto\_setup \\
	subsystem! = display \\
\end{schema}

\subsubsection{SelectDisplay operations}

There are a few simple displays that provide no selections or
interactive editing, {\bf Field Summary} (8.9.7, 191) and
the $help$ display (not discussed in~\cite{jacky92}):

\begin{zed} simple\_display == \{  field\_summary, help \} \end{zed}

\subsubsection{SelectList operations}

The specializations of $SelectList$ are {\bf Select Patient}
(8.9.3, 184) and {\bf Select Field} (8.9.4, 186).  The latter
operation only makes sense when a patient has been selected:

\begin{zed} list = \{ select\_patient, select\_field \} \end{zed}

\begin{schema}{SelectPatientList}
	SelectList \\
	\Xi Session \\
	\Delta ConsoleSession \\
\where
	input? = select\_patient \\
	nlist' = names 
\end{schema}

\begin{schema}{SelectFieldList}
	SelectList \\
	\Xi Session \\
	\Delta ConsoleSession \\
\where
	patient \neq no\_patient \\
	input? = select\_field \\
	nlist' = \dom fields
\end{schema}

\subsubsection{SelectTable operations}

The $table$ displays are {\bf Gantry/PSA} (8.9.8, 193), 
{\bf Filter/Wedge} (8.9.9, 194), {\bf Leaf Collimator} (8.9.10, 196), 
{\bf Dosimetry/Therapy Interlocks} (8.9.11, 199) and 
{\bf Calibration Factors} (8.9.13, 213):

\begin{zed}
table = \{ gantry\_psa,filter\_wedge,leaf\_collim,dose\_intlk,dose\_cal \}
\end{zed}
The constant $table\_items$ tells which items on each table can be
selected for editing or overriding (additional items may be displayed as
well).

\begin{zed}
	table\_items~ = \{ gantry\_psa \mapsto \{ gantry, collim, turnt \}, filter\_wedge \mapsto \{ filter, wedge, w\_rot \}, \\
\t5			leaf\_collim \mapsto leaves, dose\_intlk \mapsto \{ p\_dose, p\_time \}, \\
\t5		dose\_cal \mapsto\{ pt\_mode,press,temp,d\_rate,t\_fac \} \}
\end{zed}
It is necessary to separate $setting$ and $dose\_reg$ items on
different tables:

\begin{zed}
	setting\_table = \{ gantry\_psa,filter\_wedge,leaf\_collim \}
\also
	dose\_reg\_table = \{ dose\_intlk, dose\_cal \}
\end{zed}
Now that these constants are defined, the previously defined
$SelectTable$ operation requires no further specialization.

\subsubsection{ConfirmOp operations}

To begin {\bf Cancel Run} (8.9.11, 209 -- 210):

\begin{axdef}
	cancel\_run\_query: CAPTION
\end{axdef}

\begin{schema}{SelectCancelRun}
	ConfirmOp \\
\where	
	Running \\
	input? = cancel\_run \\
	op' = input? \\
	query! = cancel\_run\_query
\end{schema}
The complementary $AcceptConfirm$ operation is $CancelRunC$ (below).

\subsubsection{MenuOp operations}

At this writing there are no simple $MenuOp$ operations, only
$MenuEdit$ operations (under $Setup$, below).

\subsubsection{DialogOp operations}


\begin{axdef}
	type\_message\_prompt, store\_field\_prompt: CAPTION
\end{axdef}

To begin {\bf Write Log Message} (2.5.1, 17):

\begin{schema}{TypeMessage}
	DialogOp
\where
	input? = log\_message \\
	op' = input?  \\
	prompt! = type\_message\_prompt
\end{schema}
To begin {\bf Store Field} (8.9.5, 189 -- 188):

\begin{schema}{EditField}
	DialogOp
\where
	Setup \\
	input? = store\_field \\
	op' = input? \\
	prompt! = store\_field\_prompt
\end{schema}
These two operations are completed by the complementary $Accept$
operations, $WriteMessageC$ and $StoreFieldC$ (below).

\subsubsection{Setup operations}

Under $Setup$, there are $SelectName$, $SelectItem$, $MenuEdit$ and
$DialogEdit$ operations.

{\bf Select Patient} (8.9.3, 184 -- 185):

\begin{schema}{SelectPatientC}
	SelectName
\where
	Setup \\
	display = select\_patient \\
	Continue
\end{schema}
At this writing, $SelectPatient$ is a $Continue$ operation; the
patient list remains on the screen\footnote{We also considered
establishing $display' = select\_field$ in $SelectPatientC$.  It would
not be difficult to adopt this alternative later.}.

{\bf SelectField} (8.9.4, 186 -- 189): There are three cases.  The
simplest case occurs during experiment mode, or when the chosen field
has not yet been delivered today and the prescribed total dose and
number of fractions has not yet been exceeded (8.9.4, 187).

\begin{schema}{NewFieldC}
	SelectName \\
	ConsoleSession
\where
	Setup \\
	display = select\_field \\
\end{schema}

\begin{schema}{SelectSimpleFieldC}
	NewFieldC
\where
	mode = experiment \\
	\lor (counters~name!~dose = 0 \land \lnot exceeded(fields~name!, counters~name!)) \\
	Continue
\end{schema}
The more complicated cases arise in therapy mode when the operator
must be warned of some unusual condition (8.9.4, 187-188).  These are
$DialogOp$ operations. The name of the new field must be stored during
the dialog.  The operator may enter a preset dose or cancel
the dialog (so no new field is selected).

\begin{schema}{Console1}
	ConsoleSession \\
	new\_field: FIELD \\
\where
	new\_field \in \dom fields
\end{schema}

\begin{schema}{DoseDialogOp}
	NewFieldC \\
	DialogOp \\
	\Delta Console1 \\
\where
	op' = select\_field \\
	new\_field' = name! \\
	mode = therapy \\
\end{schema}
There are two such cases. The first arises when the same field has
already been delivered on the same day but the prescribed daily dose
has not yet been reached; the remaining dose is offered as the default
(8.9.4, 187):

\begin{axdef}
sprintf: VALUE \fun STRING \\
delivered\_prompt: NAME \cross VALUE \cross VALUE \cross VALUE \fun CAPTION \\
\end{axdef}

\begin{schema}{SelectDeliveredField}
	DoseDialogOp
\where
	counters~new\_field'~dose > 0 \\
	\lnot exceeded(fields~new\_field', counters~new\_field') \\
	(\LET d == fields~new\_field'~dose; c == counters~new\_field'~dose @ \\
\t1	 (\LET default\_dose == d-c @ \\
\t2	  buffer' = sprintf~default\_dose \land \\
\t2	   prompt! = delivered\_prompt(new\_field', d, c, default\_dose)))
\end{schema}
The other case arises when the daily dose, the total dose or the
number of fractions has been exceeded (8.9.4, 188).  No default dose
is provided.

\begin{axdef}
exceeded\_prompt: NAME \cross ACCUMULATION \cross ACCUMULATION \fun CAPTION
\end{axdef}

\begin{schema}{SelectExceededField}
	DoseDialogOp
\where
	exceeded(fields~new\_field', counters~new\_field') \\
	prompt! = exceeded\_prompt(new\_field', fields~new\_field', counters~new\_field') \\
	buffer' = empty \\
\end{schema}
The complete operation is composed of all these cases.

\begin{zed} 
	SelectFieldC \defs 
	 SelectSimpleFieldC \lor SelectDeliveredField \lor SelectExceededField
\end{zed}
After $SelectSimpleFieldC$, nothing more need be done.
$SelectExceededField$ and $SelectDeliveredField$ are succeeded by the 
$SelectFieldOp$ state, which is handled by the $SelectComplexFieldS$
operation.  

\begin{schema}{SelectFieldOp}
	Console1 \\
	Dialog \\
\where
	op = select\_field
\end{schema}

{\bf Override} (8.4, 175; 8.8.1, 181; 8.8.2, 183) is also a $ConfirmOp$
operation, enabled only when a field has been selected.  The name of
the item that the operator selected is echoed in the confirmation
dialog.  To begin {\bf Override}:

\begin{zed}
override\_table == \{ filter\_wedge, leaf\_collim, gantry\_psa, dose\_intlk \}
\end{zed}

\begin{axdef}
	override\_query: CAPTION \fun CAPTION
\end{axdef}

\begin{schema}{SelectOverride}
	ConfirmOp \\
	SelectItem \\
	\Xi Session \\
\where
	field \neq no\_field \\
	display \in override\_table \\
	input? = override\_cmd \\
	op' = input? \\
	query! = override\_query(setting\_info\_name~item)
\end{schema}
The complementary $AcceptConfirm$ operations is $OverrideC$ (below).

{\bf Edit}: There are three cases.  Calibration factors can be edited
in experiment mode (8.9.13, 215), preset dose and time can be edited
in both modes when a field is selected (8.9.11, 201--202), and other
preset items can be edited in experiment mode when a field is selected
(8.8.1, 180--181; 8.9.8, 194; 8.9.9, 196; 8.9.10, 198).

\begin{zed}
	cal\_table == \{ dose\_cal \}
\also
	dose\_table == \{ dose\_intlk \}
\also
	preset\_table == \{ filter\_wedge, leaf\_collim \}
\end{zed}

\begin{zed}
CalTable \defs [~ ConsoleSession | mode = experiment \land display \in cal\_table ~]
\end{zed}
The precondition $field \neq no\_field$ occurs elsewhere so it is
convenient to collect two cases together.

\begin{schema}{SettingTable}
	ConsoleSession
\where
	display \in dose\_table \lor (mode = experiment \land display \in preset\_table)
\end{schema}
Finally 

\begin{zed}
	SelectCalMenu \defs CalTable \land MenuEdit
\also
	SelectCalDialog \defs CalTable \land DialogEdit
\also
	SelectSettingMenu \defs SettingTable \land MenuEdit
\also
	SelectSettingDialog \defs SettingTable \land DialogEdit
\end{zed}
The complementary operations are $EditSettingC$ and $MenuSettingC$
(section~\ref{sect:gui-elts}, above).

\subsubsection{Cancel operations}

There is a special $cancel$ operation for the login process (below) so
we have to strengthen the preconditions on $Cancel$:

\begin{zed} 
	LoggedIn \defs [ Console | op \notin \{ login, password \} ]
\also
	CancelOp \defs LoggedIn \land Cancel
\end{zed}

\subsubsection{AcceptConfirm operations}

To complete {\bf Override} (8.4, 175; 8.8.1, 181; 8.8.2, 183):

\begin{schema}{OverrideC}
	AcceptConfirm \\
	item!: ITEM
\where
	op = override\_cmd \\
	item! = item
\end{schema}
To complete {\bf Cancel Run} (8.9.11, 209 -- 210):

\begin{zed} 
	CancelRunC \defs [~ AcceptConfirm | op = cancel\_run ~]
\end{zed}

\subsubsection{Accept operations}

To complete {\bf Write Log Message} (2.5.1, 17).  The $smessage$
function turns a string into a log message by prepending the timestamp
and other information.

\begin{axdef} log\_msg: STRING \fun MESSAGE \end{axdef}

\begin{schema}{WriteMessageC}
	Accept \\
	message!: MESSAGE
\where
	op = log\_message \\
	message! = log\_msg~buffer
\end{schema}

To complete {\bf Store Field} (8.9.5, 189 -- 188)\footnote{The
$message!$ output from $StoreFieldC$ is not mentioned
in~\cite{jacky92}; here we correct the omission.}.

\begin{axdef}
	sname: STRING \fun NAME \\
	store\_msg: NAME \fun MESSAGE
\end{axdef}
\begin{schema}{StoreFieldC}
	Accept \\
	field!: NAME \\
	message!: MESSAGE
\where
	op = store\_field \\
	field! = sname~buffer \\
	message! = store\_msg~field!
\end{schema}
The complex variants of {\bf Select Field} (8.9.4, 187--188) are
handled by $SelectComplexFieldC$, which is similar to $EditSettingC$:

\begin{schema}{SelectComplexFieldC}
	\Delta Console1 \\
	Accept \\
	field!: FIELD \\
	dose!: VALUE
\where
	SelectFieldOp \\
	field! = new\_field \\
	(\LET d == sval~buffer @ d \in valid~dose \land dose! = d)
\end{schema}
We have to make the operation total

\begin{zed}
InvalidDose \defs [~ Reprompt; \Delta Console1 | SelectFieldOp \land sval~buffer \notin valid~dose ~]
\end{zed}

\begin{zed}
ComplexOrInvalidField \defs SelectComplexFieldC \lor InvalidDose
\end{zed}

\subsubsection{Logout and login} \label{sect:login-console}

The {\bf Login} process (Fig. 2.6, 19) can be seen as editing the
value of $operator$.  Messages are logged at logout and login.  
{\bf Logout} (2.5.2, 17 -- 18; 8.9.2, 184) is is similar to $SelectDisplay$
and $DialogOp$; it reads $Session$ for the operator's ID in the logout
message. 

\begin{axdef}
	o\_msg, lo\_msg: OPERATOR \fun MESSAGE
\end{axdef}

\begin{schema}{Logout}
	Op \\
	\Xi Session \\
	message!: MESSAGE
\where
	Setup \\
	input? = login \\
	display' = input? \\
	op' =  display' \\
	buffer' = empty \\
	message! = lo\_msg~operator \\
	Dialog' 
\end{schema}
A successful {\bf Login} (2.5.2, 17 -- 20; 8.9.1, 183) occurs when a
user enters a valid operator identification.  The process of logging
back in is broken into two steps.  In the first step, the user types
their username into the buffer.  When the user types a terminator the
username is saved in another buffer; the $Console1$ state is $Console$
with this buffer added\footnote{The password is also typed into
$buffer$ so the $GetChar$ operation can be used.}. The console remains
logged out after this step.  This $EnterUsername$ operation is similar
to $Accept$ and $Continue$.

\begin{schema}{Console2}
	Console \\
	username: STRING
\end{schema}

\begin{schema}{EnterUsername}
	\Delta Console2 \\
	\Delta Dialog \\
	EventUnlocked
\where
	op = login \\
	input? \in terminator \\
	username' = buffer \\
	buffer' = empty \\
	op' = password \\
  	display' = display \\
\end{schema}
In the second step, the user enters their password.  If their
username, password pair is found in operator database, the user is
logged in, the help screen is displayed, and the console becomes
available.  This $LoginC$ operation is similar to $Accept$ and
$SelectDisplay$.

The operator authorization file is modelled by Z global constants
$operators$ and $physicists$ (physicists are authorized to use the
equipment in its experiment mode, see 8.2, 170).  Values of $OPERATOR$
include the operator's password in addition to the operator's printed
name.

\begin{zed} USERNAME == STRING; PASSWORD == STRING \end{zed}

\begin{axdef}
	soper: (USERNAME \cross PASSWORD) \fun OPERATOR \\
\end{axdef}

\begin{schema}{LoginC}
	\Delta Console2 \\
	EventUnlocked \\
	operator!: OPERATOR \\
	message!: MESSAGE
\where	
	op = password \\
	soper(username, buffer) \in operators \\
	input? \in terminator \\
	display' = help \\
	op' = display \\
	operator! = soper(username,buffer) \\
	message! = o\_msg~operator! \\
	Available'
\end{schema}
If the username, password pair is not found in the authorization file,
the console remains logged out.  

\begin{schema}{Unauthorized}
	\Delta Console2 \\
	Reprompt 
\where
	op = password \\
	soper(username,buffer) \notin operators \\
	username' = username   
\end{schema}

\begin{zed} LoginOrUnauthorized \defs LoginC \lor Unauthorized \end{zed}
Users may cancel a login attempt while entering their username or
password.  The login process begins anew.

\begin{schema}{CancelUsername}
	\Delta Console2 \\
	\Delta Dialog \\
	EventUnlocked
\where
	op \in \{ login, password \} \\
	input?  = cancel \\
	op' = login \\
	buffer'  = empty \\
	username' = empty \\
	display' = display
\end{schema}

\subsubsection{Other operations}

Several operations not described in~\cite{jacky92} are included for
development purposes\footnote{$Shutdown$ will not be included in
production versions.}.  They are always enabled.

\begin{zed}
	Refresh \defs [~ Event | input? = refresh ~]
\also
	Shutdown \defs [~ Event | input? = shutdown ~]
\end{zed}

This concludes our presention of the states and operations in the user
interface.

\section{Combining the subsystems} \label{sect:compose}

In this section we combine related operations from the $Console$,
$Session$ and $Field$ subsystems.  In cases where no data is
transferred between subsystems, we can simply conjoin the separate
operations:

\begin{zed} ExptMode \defs ExptModeC \land ExptModeS \land ExptModeF \end{zed}
Here the conjunction just expresses that the named operations in all
three subsystems are triggered by the $expt\_mode$ input at the
console.  In this report both $ExptModeC$ and $ExptModeS$ contain the
precondition $operator \in physicists$, but this predicate only needs
to appear once; we include it in both schemas for clarity\footnote{In our
implementation, we observe the convention that preconditions of
combined operations are always tested in the $Console$
operations.  For example $operator \in physicists$
is tested by code in {\tt zconsole.c}, not {\tt zsession.c}.}.

In other cases, data is transferred.  For example, in the $Override$
operation, the $item!$ output from the $Console$ subsystem is
consumed by the $item?$ input in the $Field$ subsystem (the $Session$
subsystem does not participate in this operation).  We wish to
express

%%unchecked - avoid spurious msgs
\begin{schema}{Override}
	OverrideC \\
	OverrideF
\where
	item! = item?
\end{schema}
This can be expressed more concisely using the Z {\em pipe} operator
$\pipe$, which has the effect of connecting corresponding input and
output variables (\cite{spivey92}, p. 78)\footnote{The Z pipe operator
also hides the piped variables.}.

\begin{zed} Override \defs OverrideC \pipe OverrideF \end{zed}
In $Login$, the new operator name $operator!/operator?$ is the piped variable.

\begin{zed} Login \defs LoginC \pipe LoginS \end{zed}
In $EditSetting$, both the item name $item!/item?$ and the
new setting value $value!/value?$ are piped:

\begin{zed} EditSetting \defs EditSettingC \pipe EditSettingF \end{zed}
Sometimes the output from the $Console$ subsystem is piped to inputs in
both the $Session$ and $Field$ subsystems.  In $StoreField$, the new
field name $field! / field?$ is the piped variable:

\begin{zed} 
	StoreField \defs StoreFieldC \pipe (StoreFieldS \land StoreFieldF)
\end{zed}
Here the conjunction $StoreFieldS \land StoreFieldF$ ensures that
$prescribed'$ in $fields' = fields \cup \{ field' \mapsto prescribed' \}$ 
from $StoreFieldS$ is the same as $prescribed'$ in
$prescribed' = prescribed \oplus  measured \dots$ from $StoreFieldF$.

In $SelectPatient$, the new patient name $patient!/patient?$ is the
piped variable ($patient?$ does not appear in $SelectPatientF$).

\begin{zed} 
SelectPatient \defs SelectPatientC \pipe (SelectPatientS \land SelectPatientF)
\end{zed}
There are two variations of 
$SelectField$.  In both variants $field!/field?$ is piped from 
the $SelectFieldC$ variant to $SelectFieldS$.  In the complex variant,
$dose!/dose?$ is piped from $SelectComplexFieldS$ to $SelectComplexFieldF$.

\begin{zed} 
	SelectSimpleField \defs SelectSimpleFieldC \pipe (SelectFieldS \land SelectSimpleFieldF)
\also
	SelectComplexField \defs SelectComplexFieldC \pipe (SelectFieldS \land SelectComplexFieldF)
\end{zed}











% glossary.tex

\section*{Glossary of Z Notation} \label{app:gloss}

This glossary is based on the one by Jonathan Bowen at the Z home page, \\
{\tt http://www.comlab.ox.ac.uk/archive/z.html}.  

It includes all the notation used in {\em The Way of Z}.

\paragraph{Names}

\begin{tabbing}
xxxxxxxxxxx \= \kill \\ 
$a,b$ \> identifiers \\
$d,e$ \> declarations (e.g., $a: A; b, \dots: B \dots$) \\
$f,g$ \> functions \\
$m,n$ \> numbers \\
$p,q$ \> predicates \\
$s,t$ \> sequences \\
$x,y$ \> expressions \\
$A,B$ \> sets \\
$C,D$ \> bags \\
$Q,R$ \> relations \\
$S,T$ \> schemas \\
$X$ \> schema text (e.g., $d$, $d | p$, or $S$) \\
\end{tabbing}

\paragraph{Definitions}

\begin{tabbing}
xxxxxxxxxxx \= \kill \\ 
$a == x$ \>  Abbreviation definition \\
$a ::= b | \dots$ \> Free type definition \\
$[a]$ \> Introduction of a given set (or $[a,\dots]$) \\
$a \_$ \> Prefix operator \\
$\_ a$ \> Postfix operator \\
$\_ a \_$ \> Infix operator \\
\end{tabbing}

\newpage

\paragraph{Logic}

\begin{tabbing}
xxxxxxxxxxxxxxxxxxx \= \kill \\ 
$true$ \> Logical true constant \\
$false$ \> Logical false constant \\
$\lnot p$ \> Logical negation, {\em not} \\
$p \land q$ \> Logical conjunction, {\em and} \\
$p \lor q$ \> Logical disjunction, {\em or} \\
$p \implies q$ \> Logical implication \\
$p \iff q$ \> Logical equivalence \\
$\forall X @ q$ \> Universal quantification \\
$\exists X @ q$ \> Existential quantification \\
$(\LET a == x; \dots @ p)$ \> Local definition \\
\end{tabbing}

\paragraph{Sets and expressions}

\begin{tabbing}
xxxxxxxxxxxxxxxxxxx \= \kill \\ 
$x = y$ \> Equality \\
$x \neq y$ \> Inequality \\
$x \in A$ \> Set membership \\
$x \notin A$ \> Non-membership \\
$\emptyset$ \> Empty set \\
$A \subseteq B$ \> Set inclusion \\
$A \subset B$ \> Strict set inclusion \\
$\{ x, y, \dots \}$ \> Set display \\
$\{~ X @ x ~\}$ \> Set comprehension \\
$(\lambda X @ x)$ \> Lambda expression \\
$(\LET a == x; \dots @ y)$ \> Local definition \\
$\IF p \THEN x \ELSE y$ \> Conditional expression \\
$(x,y, \dots)$ \> Tuple \\
$(x,y)$ \> Pair \\
$A \cross B \cross \dots$ \> Cartesian product \\
$\power A$ \> Power set \\
$A \cap B$ \> Set intersection \\
$A \cup B$ \> Set union \\
$A \setminus B$ \> Set difference \\
$first~x$ \> First element of an ordered pair \\
$second~x$ \> Second element of an ordered pair \\
$\# A$ \> Number of elements in a set \\
\end{tabbing}

\paragraph{Relations}

\begin{tabbing}
xxxxxxxxxxx \= \kill \\ 
$A \rel B$ \> Binary relation ($\power (A \cross B)$) \\
$a \mapsto b$ \> Maplet ($(a,b)$) \\
$\dom R$ \> Domain of a relation \\
$\ran R$ \> Range of a relation \\
$Q \comp R$ \> Forward relational composition \\
$Q \circ R$ \> Backward relational composition ($R \comp Q$) \\
$A \dres R$ \> Domain restriction \\
$A \ndres R$ \> Domain anti-restriction \\
$A \rres R$ \> Range restriction \\
$A \nrres R$ \> Range anti-restriction \\
$R \limg A \rimg$ \> Relational image \\
$R \inv$ \> Inverse of relation \\
$R \plus$ \> Transitive closure \\
$Q \oplus R$ \> Relational overriding \\
$a \inrel{R} b$ \> Infix relation \\
\end{tabbing}

\paragraph{Functions}

\begin{tabbing}
xxxxxxxxxxx \= \kill \\ 
$A \pfun B$ \> Partial functions \\
$A \fun B$ \> Total functions \\
$A \pinj B$ \> Partial injections \\
$A \inj B$ \> Total injections \\
$A \bij B$ \> Bijections \\
$f~x$ \> Function application (or $f(x)$) \\
\end{tabbing}

\paragraph{Numbers}

\begin{tabbing}
xxxxxxxxxxx \= \kill \\ 
$\num$ \> Set of integers \\
$\nat$ \> Set of natural numbers $\{ 0, 1, 2, \dots \}$ \\
$\nat_1$ \> Set of strictly positive numbers $\{ 1, 2, \dots \}$ \\
$m+n$ \> Addition \\
$m-n$ \> Subtraction \\
$m*n$ \> Multiplication \\
$m \div n$ \> Division \\
$m \mod n$ \> Remainder (modulus) \\
$m \leq n$ \> Less than or equal \\
$m < n$ \> Less than \\
$m \geq n$ \> Greater than or equal \\
$m > n$ \> Greater than \\
$m \upto n$ \> Number range \\
$min~A$ \> Minimum of a set of numbers \\
$max~A$ \> Maximum of a set of numbers \\
\end{tabbing}

\paragraph{Sequences}

\begin{tabbing}
xxxxxxxxxxx \= \kill \\ 
$\seq A$ \> Set of finite sequences \\
$\seq_1 A$ \> Set of non-empty finite sequences \\
$\iseq A$ \> Set of finite injective sequences \\
$\langle \rangle$ \> Empty sequence \\
$\langle x, y, \dots \rangle$ \> Sequence display \\
$s \cat t$ \> Sequence concatenation \\
$head~s$ \> First element of a sequence \\
$tail~s$ \> All but the head element of a sequence \\
$last~s$ \> Last element of a sequence \\
$front~s$ \> All but the last element of a sequence \\
$s \inseq t$ \> Sequence segment relation \\
\end{tabbing}

\paragraph{Schema}

\begin{schema}{S}
	d
\where
	p
\end{schema}

\newpage


\paragraph{Axiomatic definition}

\begin{axdef}
	d
\where
	p
\end{axdef}

\paragraph{Generic definition}

\begin{gendef}[a, \dots]
	d
\where
	p
\end{gendef}

\paragraph{Schema calculus}

\begin{tabbing}
xxxxxxxxxxxxxx \= \kill \\ 
$S \defs [~ X ~]$ \> Horizontal schema \\
$[~ T; \dots | \dots ~]$  \> Schema inclusion \\
$z.a$ \> Component selection (given $z:S$) \\
$\theta S$ \> Binding \\
$\lnot S$ \> Schema negation \\
$S \land T$ \> Schema conjunction \\
$S \lor T$ \> Schema disjunction \\
$S \semi T$ \> Schema composition \\
$S \pipe T$ \> Schema piping \\
\end{tabbing}

\paragraph{Conventions}

\begin{tabbing}
xxxxxxxxxxxxxx \= \kill \\ 
$a?$ \> Input to an operation \\
$a!$ \> Output from an operation \\
$a$ \> State component before an operation \\
$a'$ \> State component after an operation \\
$S$ \> State schema before an operation \\
$S'$ \> State schema after an operation \\
$\Delta S$ \> Change of state \\
$\Xi S$ \> No change of state \\
\end{tabbing}












\section{The Z Mathematical Tool-kit} \label{ch:toolkit}

The Z mathematical tool-kit is a collection of types and operators
somewhat like a standard library of types and functions in a
programming language.

The definitions in the tool-kit build up all the Z operators from
a few fundamental constructs in logic and set theory.

The tool-kit uses generic definitions very heavily: $X$, $Y$, and $Z$
stand for any type, $S$ and $T$ are sets of any type, and $Q$ and $R$
are binary relations between any two types.  The toolkit also makes
extensive use of patterns in abbreviation definitions, for example it
defines the binary relation symbol $\rel$ by $X \rel Y == \power (X \cross Y)$.

These selections from the tool-kit are based on the 
{\em Reference Manual}.  They define all the operators used in 
{\em The Way of Z}, and a few more that are needed to define them.
In a few places I've used English paraphrases for predicates, where
the formal definition uses constructs or concepts not defined here.

\newpage

\section*{Sets}

\subsection*{Glossary}

\begin{tabular}{l c l}
$\emptyset$ & ~-~ & Empty set: a set that has no elements \\
$x \notin S$ & ~-~ & Non-membership: $x$ is not an element of $S$ \\
$S \subseteq T$ & ~-~ & Subset: all elements of $S$ belong to $T$ \\
$S \subset T$ & ~-~ & Proper subset: $S$ is a subset of $T$ and $S$ is not equal to $T$ \\
$S \cup T$ & ~-~ & Union: the set of elements in either $S$ or $T$ \\
$S \cap T$ & ~-~ & Intersection: the set of elements in both $S$ and $T$ \\
$S \setminus T$ & ~-~ & Set difference: the set of elements in $S$ that are not in $T$ \\
\end{tabular}

\subsection*{Definitions}

\begin{zed} \emptyset[X] == \{~ x: X | false ~\} \end{zed}

\begin{gendef}[X]
	\_ \subseteq \_, \_ \subset \_ : \power X \rel \power X \\ 
   	\_ \cup \_ , \_ \cap \_, \_ \setminus \_: \power X \cross \power X \fun \power X \\
\where
	\forall x: X; y: Y; S, T: \power X @ 
\also
\t1	x \notin S \iff \lnot (x \in X) \land
\also
\t1	(S \subseteq T \iff (\forall x: X @ x \in S \implies x \in T)) \land
\also
\t1	(S \subset T \iff S \subseteq T \land S \neq T) \land
\also 
\t1	S \cup T = \{~ x: X | x \in S \lor X \in T ~\} \land
\also 
\t1	S \cap T = \{~ x: X | x \in S \land X \in T ~\} \land
\also 
\t1	S \setminus T = \{~ x: X | x \in S \land X \notin T ~\}
\also
\end{gendef}

\newpage

\section*{Pairs and binary relations I}

\subsection*{Glossary}

\begin{tabular}{l c l}
$(x,y)$	  & ~-~ & The pair $x$,$y$ \\
$x \mapsto y$ & ~-~ & Maplet: $x$ maps to $y$, same as $(x,y)$ \\
$first~p$ & ~-~ & First element of pair $p$ \\
$second~p$ & ~-~ & Second element of pair $p$ \\
$\id X$ & ~-~ & Identity relation \\
$X \rel Y$ & ~-~ & Binary relation \\
$\dom R$ & ~-~ & Domain: the set of first elements of all pairs in $R$ \\
$\ran R$ & ~-~ & Range: the set of second elements of all pairs in $R$ \\
\end{tabular}

\subsection*{Definitions}

\begin{zed} 
	X \rel Y == \power (X \cross Y)
\also
	\id X == \{ x: X @ x \mapsto x \}
\end{zed}

\begin{gendef}[X,Y]
	first: X \cross Y \fun X \\
	second: X \cross Y \fun Y \\
	\_ \mapsto \_ : X \cross Y \fun X \cross Y \\
	\dom: (X \rel Y) \fun \power X \\
	\ran: (X \rel Y) \fun \power Y \\
\where
	\forall x: X; y: Y; R: X \rel Y @ \\
\also
\t1	first(x,y) = x \land
\also
\t1	second(x,y) = y \land
\also
\t1	x \mapsto y = (x,y) \land
\also
\t1	\dom R = \{~ x: X; y: Y | x \inrel{R} y @ x ~\} \land	
\also
\t1	\ran R = \{~ x: X; y: Y | x \inrel{R} y @ y ~\}
\also
\end{gendef}

\newpage

\section*{Pairs and binary relations II}

\subsection*{Glossary}

\begin{tabular}{l c l}
$S \dres R$ & ~-~ & Domain restriction: the pairs in $R$ whose first element is in $S$ \\
$R \rres T$ & ~-~ & Range restriction: the pairs in $R$ whose second element is in $T$ \\
$S \dres R$ & ~-~ & Domain antirestriction: the pairs in $R$ whose first element is not in $S$ \\
$R \rres T$ & ~-~ & Range antirestriction: the pairs in $R$ whose second element is not in $T$ \\
$R \inv$ & ~-~ & Relational inverse: the  pairs in $R$, \\
	&  & but with first and second elements exchanged \\
$R \limg S \rimg$ & ~-~ & Relational image: the second elements of pairs \\
		&  & in $R$ whose first element is in $S$. \\
$R \oplus Q$ & ~-~ & Overriding: all pairs in $R$ or $Q$, \\
	& & except pairs in $R$ whose first element is also in $Q$. \\
$R \plus$ & ~-~ & Transitive closure of $R$ \\
\end{tabular}

\subsection*{Definitions}

\begin{gendef}[X,Y]
	\_ \dres \_, \_ \ndres \_ : \power X \cross (X \rel Y) \fun X \rel Y \\
	\_ \rres \_, \_ \nrres \_ : (X \rel Y)  \cross  \power Y \fun X \rel Y \\
	\_ \inv : (X \rel Y) \fun (Y \rel X) \\
	\_ \limg \_ \rimg : (X \rel Y) \cross \power X \fun \power Y \\
	\_ \oplus \_ : (X \rel Y) \cross (X \rel Y) \fun (X \rel Y) \\
	\_ \plus : (X \rel X) \fun (X \rel X)
\where
	\forall x: X; y: Y; S: \power X; T: \power Y; Q, R: X \rel Y @ \\
\also
\t1 S \dres R = \{~ x: X; y: Y | x \in S \land x \inrel{R} y @ x \mapsto y ~\} \land	
\also
\t1 S \ndres R = \{~ x: X; y: Y | x \notin S \land x \inrel{R} y @ x \mapsto y ~\} \land	
\also
\t1 R \rres T = \{~ x: X; y: Y | x \inrel{R} y \land y \in T @ x \mapsto y ~\} \land	
\also
\t1 R \nrres T = \{~ x: X; y: Y | x \inrel{R} y \land y \notin T @ x \mapsto y ~\} \land	
\also	
\t1	R \inv = \{~ x: X; y: Y | x \inrel{R} y @ y \mapsto x ~\} \land \\
\also 
\t1 R \limg S \rimg = \{~ x: X; y: Y | x \in S \land x \inrel{R} y @ y ~\} \land	
\also
\t1	Q \oplus R = ((\dom R) \ndres Q) \cup R
\also
\t1	\mbox{\dots predicate for $\_ \plus$ omitted \dots}
\also
\end{gendef}


\newpage

\section*{Pairs and binary relations III}

\subsection*{Glossary}

\begin{tabular}{l c l}
$Q \comp R$ & ~-~ & Relational composition: $Q$ composed with $R$ \\
$R \circ Q$ & ~-~ & Backward relational composition, same as $Q \comp R$ \\
\end{tabular}

\subsection*{Definitions}

\begin{gendef}[X,Y,Z]
	\_ \comp \_ : (X \rel Y) \cross (Y \rel Z) \fun (X \rel Z) \\
	\_ \circ \_ : (Y \rel Z) \cross (X \rel Y) \fun (X \rel Z) \\
\where
	\forall Q: X \rel Y; R: Y \rel Z @ \\
\t3		Q \comp R = R \circ Q = \{~ x: X; y: Y; z: Z | x \inrel{Q} y \land y \inrel{R} z @ x \mapsto z ~\}
\end{gendef}

\newpage

\section*{Numbers and arithmetic}

\subsection*{Glossary}

\begin{tabular}{l c l}
$\num$ & ~-~ & The set of integers \\
$\nat$ & ~-~ & The set of natural numbers, starting with zero \\
$\nat_1$ & ~-~ & The set of strictly positive numbers, starting with one \\
$+,-,*$ & ~-~ & Arithmetic operators: addition, subtraction, multiplication \\
$\div,\mod$ & ~-~ & Arithmetic operators: integer division and remainder (modulus) \\
$<,\leq$ & ~-~ &  Comparison: less than, less than or equal \\
$>, \geq$ & ~-~ & Comparison: greater than, greater than or equal \\
$i \upto j$ & ~-~ & Number range: the set of numbers starting with $i$ up through $j$ \\
$min~S$ & ~-~ & Mininum: the smallest element in $S$, if any \\
$max~S$ & ~-~ & Maximum: the largest element in $S$, if any \\
$\# S$	& ~-~ & Size: the number of elements in $S$ \\
$\power_1$ & ~-~ & Non-empty sets \\
$\finset$ & ~-~ & Finite sets \\
\end{tabular}

\subsection*{Definitions}

\begin{zed} 
	[\num]
\also
	\nat == \{~ n: \num | n \geq 0 ~\}
\also
	\nat_1 == \nat \setminus \{ 0 \}
\also
	\power_1 X == \{~ S: \power X | S \neq \emptyset ~\}
\also
	\finset X == \{~ S: \power X | \mbox{\dots $S$ is finite \dots} ~\}
\end{zed}

\begin{axdef}
	\_ + \_, \_ - \_, \_* \_ : \num \cross \num \fun \num \\
      \_ \div \_, \_ \mod \_ : \num \fun (\num \setminus \{ 0 \}) \fun \num \\
	\_ - : \num \fun \num \\
	\_ < \_, \_ \leq \_, \_ \geq \_, \_ > \_ : \num \rel \num \\
	\_ \upto \_ : \num \rel \num \fun \power \num \\
	\#: \finset X \fun \nat \\
	min, max: \power_1 \num \pfun \num
\where
	\forall a,b: \num @ a \upto b = \{~ i: \num | a \leq i \leq b ~\} \\
\also
\t1	\mbox{\dots predicates for other operators omitted \dots}
\end{axdef}

\newpage

\section*{Functions}

\subsection*{Glossary}

\begin{tabular}{l c l}
$X \pfun Y$ & ~-~ & Partial function: some members of $X$ are paired with a member of $Y$ \\
$X \fun Y$ & ~-~ & Total function: every member of $X$ is paired with a member of $Y$ \\
$X \pinj Y$ & ~-~ & Partial injection:  some members of $X$ are paired with different members of $Y$ \\
$X \inj Y$ & ~-~ & Total injection: every member of $X$ is paired with a different member of $Y$ \\
$X \bij Y$ & ~-~ & Bijection: every member of $X$ is paired with a different member of $Y$, \\
	& & covering all $Y$'s \\
\end{tabular}

\subsection*{Definitions}

\begin{zed}
 X \pfun Y == \{~ f: X \rel Y | \mbox{Each member of $X$ appears no more than once.} ~\}
\also
 X \fun Y == \{~ f: X \pfun Y | \dom f = X ~\}
\also
 X \pinj Y == \{~ f: X \pfun Y | \mbox{Each member of $X$ is paired with a different member of $Y$.} ~\}
\also
 X \inj Y == (X \pinj Y) \cap (X \fun Y)
\also
 X \bij Y == \mbox{ \dots definition omitted \dots }
\end{zed}

\newpage

\section*{Sequences}

\subsection*{Glossary}

\begin{tabular}{l c l}
$\seq X$ & ~-~ & Sequence: the set of all sequences of $X$'s \\
$\seq_1 X$ & ~-~ & Non-empty sequence: the set of all sequences of $X$'s \\
	&  & with at least one element \\
$\iseq X$ & ~-~ & Injective sequence: the set of all sequences of $X$'s \\
	&  & where each element of $X$ appears only once \\
$s \cat t$ & ~-~ & Concatenation: sequence $s$ with sequence $t$ appended \\
$head~s$ & ~-~ & Head: the first element of sequence $s$ \\
$last~s$ & ~-~ & Last: the last element of sequence $s$ \\
$front~s$ & ~-~ & Front: all but the last element of sequence $s$ \\
$tail~s$ & ~-~ & Tail: all but the first element of sequence $s$ \\
$s \inseq t$ & ~-~ & Segment relation: the sequence $s$ appears in sequence $t$
\end{tabular}

\subsection*{Definitions}

\begin{zed}
	\seq X == \{~ f: \nat \ffun X | \dom f = 1 \upto \# f ~\}
\also
	\seq_1 X == \{~ f: \seq X | \# f > 0 ~\}
\also
	\iseq X == \seq X \cap (\nat \pinj X)
\end{zed}

\begin{gendef}[X]
	head, last : \seq_1 X \fun X \\
	tail, front : \seq_1 X \fun \seq X \\
	\_ \cat \_ : \seq X \cross \seq X \fun seq X \\
	\_ \inseq \_ : \seq X \rel \seq X \\
\where
	\forall s: \seq_1 X; u,v: \seq X @ \\
\also 
\t1	head(s) = s(1) \land
\also
\t1	last(s) = s(\# s) \land
\also
\t1	u \cat v = u \cup \{~ i: \dom v @ i + \#u \mapsto v(i) ~\}
\also
\t1	u \inseq v \iff (\exists s,t: \seq X @ s \cat u \cat t = v) 
\also
\t1	\mbox{\dots predicates for other operators omitted \dots}
\also
\end{gendef}
\end{document}